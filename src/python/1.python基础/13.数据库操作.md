---
footer: false
prev: false
next: false
---

# 13.数据库操作

## 1，MySQL

### 1.1 基础知识

```SQL
# DB：数据库，他保存了一系列有组织的数据；
# DBMS：数据库管理系统；
# SQL：结构化查询语言，用来与数据库进行沟通；
```

#### 1.1.1 MySQL 服务的登录和退出

```sql
# 1，通过 Windows 自带的客户端
    # 登录：MySQL -h 主机名 -p 端口号 -u 用户名 -p 密码（-p 和密码之间不能有空格）
    # 退出：exit
```

#### 1.1.2 查看数据库的版本号

```sql
## 1，Windows 客户端进入 MySQL,写 SQL 命令
    select version();
## 2，Windows 客户端写
    MySQL --version*（结尾没有分号）
```

#### 1.1.3 MySQL 语法规范

```sql
## 1. 不区分大小写，建议关键字大写，表名，列名小写
## 2. 每条命令最好分号结尾；
## 3. 每条命令根据需要进行缩进，换行；
## 4. 注释
    1,单行注释：# 注释内容；
    2,单行注释：-- 注释内容（-- 后面必须有空格）
    3,多行注释：/* 注释内容 */
```

#### 1.1.4 SQL 语言

```sql
## 1. DQL：数据查询语言；select
## 2. DML：数据操作语言 增删改
## 3. DDL：数据定义语言
## 4. TCL：事务控制语言
```

### 1.2 DQL 基础查询语言

#### 1.2.1 进阶 1：DQL 基础查询

##### 1-1 代码格式化

```SQL
## F12 可以对代码进行格式化；
```

##### 1-2 简单查询

```sql
# 查询单个字段
select last_name from employees;

# 查询表中的多个字段
select last_name , salary,email from employees;

# 查询表中的所有字段
select * from employees;

# 查询常量表达式
select 100;
select 'aini';
select 100*98;
select version();
```

##### 1-3 起别名

```sql
## as 关键字

    ## 方式一
        select 98 * 100 as 运算结果
        select last_name as 姓, first_name as 名 from employees;

    ## 方式二
        select last_name 姓,first_name 名 from employees;

    ## 注意：特殊字符如#,关键字 建议加上双引号;
        select salaty as "out put" from employess;
```

##### 1-4 去重

```sql
# 去重 distinct

## 查询员工表中涉及到的所有部门编号
select distinct department_id from employees;
```

##### 1-5 +的作用

```sql
## 两个操作数是数值，则做加法运算；
## 其中一个为字符串时，试图将其转换为数值，转换成功继续做数值的加法运算；如果转换失败，则将此字符串转换为 0；如果其中一方为 	null，则结果已经为 null；

select "aini" + 20   # 20
select 50 + 30       # 80
select "a" + "b"     # 0
```

##### 1-6 concat 函数

```sql
## Null 与任何字段，任何数据拼接结果都是 null

select concat('a','b','c') as 字符连接;
select concat(last_name,first_name) as 姓名 from employees;
```

##### 1-7 IFNULL 函数

```python
## 1，IFNULL(x,y) x 为判断的值，y 为返回的值 ，意思就是假如 x 是 null
select ifnull(commission_puc,0) as 奖金率,commission-puc from employees;

## null 的地方会返回函数里面设置的值，不是null 的地方会返回本身的值
```

#### 1.2.2 进阶 2：条件查询

##### 2-1 条件查询分类

```sql
# 按条件表达式进行筛选
    >  < = !=  <>  >=   <=

# 按逻辑表达式进行筛选
    && || !  and  not or

# 模糊查询
    like ,  between  and ,  in  , null
```

##### 2-2 条件表达式查询

```sql
# 查询工资>12000的员工信息；
    select * from employees where salaty > 12000;

# 查询部门编号不等于90号的员工名和部门编号
    select last_anme ,department_id from employees where department_id <> 90;
```

##### 2-3 按逻辑表达式筛选

```sql
# 查询员工工资在10000 到 20000 之间的员工名，工资，奖金
    select last_name,salary commistion_put from employees where salary >= 10000 and salary <= 20000;

# 查询部门编号不是在90 到 110 之间的，或者工资高于15000的员工信息；
    select * from employees where department_id < 90 or department_id > 110 or salary > 15000;
    select * from employees where not  (department_id >= 90 and department_id <= 110) or salary > 15000;
```

##### 2-4 模糊查询

###### 4.1 通配符

```sql
# %表示任意多个字符，也包含零个字符；
# _表示任意单个字符
```

###### 4-2 like

```sql
# 查询员工名中包含字符a的员工信息
    select * from employees where last_name like '%a%';

# 查询员工名中第三个字符为e的，第五个字符为a的员工名
    select last_name from employees where last_name like '__e_a%'

# 查询员工名中第二字符为下划线的员工名
    select last_name from employees where last_name like '_\_%';  # 需要对下划线进项转义

# 自定义转义符号
    select last_name from employees where last_name like '_$_%' escape '$';
    select last_name from employees where last_name like '_z_%' escape 'z';
```

###### 4-3 between and

```sql
# 包含临界值，临界值不能颠倒

# 查询员工编号在100到120之间的员工信息
    select * from employees where employee_id between 100 and 120;
```

###### 4-4 in

```sql
## 判断值是否等于in列表中的某一项
## 不支持括号里使用通配符
## in 列表的值类型必须统一或兼容

# 查询员工的工种编号是IT_PROG,AD_VP,AD_PRES 中的一个工种名和工种编号；
    select last_name ,job_id from employees where job_id in ('IT_PROG','AD_VP','AD_PRES')
```

###### 4-5 is null

```sql
## 不能用来判断字段值是否为空

## 查询没有奖金的员工和奖金率
    select last_name,commistion_pct from employees where commisstion_pct is null
    ## = 不能判断字段值是否为Null，所以使用is null

## 查询有奖金的员工和奖金率
    select last_name,commistion_pct from employees where commission-pct is not null
```

###### 4-6 安全等于

```sql
#案例1：查询没有奖金的员工名和奖金率
SELECT
    last_name,
    commission_pct
FROM
    employees
WHERE
    commission_pct <=>NULL;

#案例2：查询工资为12000的员工信息
SELECT
    last_name,
    salary
FROM
    employees

WHERE
    salary <=> 12000;
```

###### 4-7 Isnull 函数

```sql
## 功能：判断一个字段值是否为 null；
## Isnull（字段名），就一个参数，值为 null 返回 1，值不是为空则返回 0；

# IS NULL:仅仅可以判断NULL值，可读性较高，建议使用
## <=>   :既可以判断NULL值，又可以判断普通的数值，可读性较低
```

#### 1.2.3 进阶 3：排序

```SQL
/*
特点：
1、asc代表的是升序，可以省略   desc代表的是降序
2、order by子句可以支持 单个字段、别名、表达式、函数、多个字段
3、order by子句在查询语句的最后面，除了limit子句
*/

#1、按单个字段排序
SELECT * FROM employees ORDER BY salary DESC;

#2、添加筛选条件再排序
#案例：查询部门编号>=90的员工信息，并按员工编号降序
SELECT *
FROM employees
WHERE department_id>=90
ORDER BY employee_id DESC;

#3、按表达式排序
#案例：查询员工信息 按年薪降序
SELECT *,salary*12*(1+IFNULL(commission_pct,0))
FROM employees
ORDER BY salary*12*(1+IFNULL(commission_pct,0)) DESC;

#4、按别名排序
#案例：查询员工信息 按年薪升序
SELECT *,salary*12*(1+IFNULL(commission_pct,0)) 年薪
FROM employees
ORDER BY 年薪 ASC;

#5、按函数排序
#案例：查询员工名，并且按名字的长度降序

SELECT LENGTH(last_name),last_name
FROM employees
ORDER BY LENGTH(last_name) DESC;

#6、按多个字段排序
#案例：查询员工信息，要求先按工资降序，再按employee_id升序
SELECT *
FROM employees
ORDER BY salary DESC,employee_id ASC;

```

![img](Python3%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.assets/wps1.png)

```SQL
## Order by 语句一般放在最后
```

#### 1.2.4 进阶 4：常见函数介绍

##### 4-1 分类

```SQL
## 分类：
    ## 单行函数：
        ## Concat() ; length() ; ifnull() ; isnull() 等；
    ## 分组函数：
        ## 功能：做统计使用，统计函数；

##单行函数：
    ## 1. 字符函数：
    ## 2. 数学函数：
    ## 3. 日期函数：
    ## 4. 其他函数：
    ## 5. 流程控制函数：
```

##### 4-2 字符函数

###### 2-1 length(str)

```sql
## 注一个汉字占三个字节

SELECT LENGTH('john');
SELECT LENGTH('张三丰hahaha');

SHOW VARIABLES LIKE '%char%'
```

###### 2-2 concat

```sql
SELECT CONCAT(last_name,'_',first_name) 姓名 FROM employees;
```

###### 2-3 upper,lower

```python
SELECT UPPER('john');
SELECT LOWER('joHn');
#示例：将姓变大写，名变小写，然后拼接
SELECT CONCAT(UPPER(last_name),LOWER(first_name))  姓名 FROM employees;
```

###### 2-4 substr,substring

```sql
# 注意：索引从1开始
#截取从指定索引处后面所有字符
SELECT SUBSTR('李莫愁爱上了陆展元',7)  out_put;

#截取从指定索引处指定字符长度的字符
SELECT SUBSTR('李莫愁爱上了陆展元',1,3) out_put;

#案例：姓名中首字符大写，其他字符小写然后用_拼接，显示出来

SELECT CONCAT(UPPER(SUBSTR(last_name,1,1)),'_',LOWER(SUBSTR(last_name,2)))  out_put FROM employees;
```

```sql
## 可以放三个参数，第一个为字段或要截取的字符串，第二个是开始位置的索引，第三个是长度
```

###### 2-5 instr

```sql
## Instr 返回一个小字符串在大字符串里面的第一次出现的起始索引找不到就返回 0
SELECT INSTR('杨不殷六侠悔爱上了殷六侠','殷八侠') AS out_put;
```

###### 2-6 trim

```sql
# 只去掉前后的空格或者前后的某个指定字符
SELECT LENGTH(TRIM('    张翠山    ')) AS out_put;

SELECT TRIM('aa' FROM 'aaaaaaaaa张aaaaaaaaaaaa翠山aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa')  AS out_put;
```

###### 2-7 lpad

```sql
## lpad 在左边填充指定字符，到指定长度（指定长度指的是总长度）
SELECT LPAD('殷素素',2,'*') AS out_put;
```

###### 2-8 rpad

```sql
## 8，rpad 右填充，跟lpad同理
SELECT RPAD('殷素素',12,'ab') AS out_put;
```

###### 2-9 replace

```sql
## replace 替换 ，可以把所有被替换的内容都替换掉
## 三个参数(字符串,’被替换的内容’,’替换的新内容’)
SELECT REPLACE('周芷若周芷若周芷若周芷若张无忌爱上了周芷若','周芷若','赵敏') AS out_put;
```

##### 4-3 数学函数

###### 3-1 round

```sql
## 一个参数，直接四舍五入到整数，第二个参数可以设置保留的小数位数
SELECT ROUND(1.567,2);
SELECT ROUND(-1.55);
```

###### 3-2 floor

```sql
SELECT FLOOR(-9.99);
```

###### 3-3 ceil

```sql
SELECT CEIL(-1.02);
```

###### 3-4 truncate 截断

```sql
SELECT TRUNCATE(1.69999,1);
## 结果是 1.6
```

###### 3-5 mod

```sql
SELECT MOD(10,-3);
SELECT 10%3;
```

##### 4-3 日期函数

###### 3-1 now

```sql
#now 返回当前系统日期+时间
SELECT NOW();
```

###### 3-2 curdate

```sql
#curdate 返回当前系统日期，不包含时间
SELECT CURDATE();
```

###### 3-3 curtime

```sql
#curtime 返回当前时间，不包含日期
SELECT CURTIME();
```

###### 3-4 获取指定部分

```sql
#可以获取指定的部分，年、月、日、小时、分钟、秒
SELECT YEAR(NOW()) 年;
SELECT YEAR('1998-1-1') 年;

SELECT  YEAR(hiredate) 年 FROM employees;

SELECT MONTH(NOW()) 月;
SELECT MONTHNAME(NOW()) 月;


#str_to_date 将字符通过指定的格式转换成日期
SELECT STR_TO_DATE('1998-3-2','%Y-%c-%d') AS out_put;

#查询入职日期为1992--4-3的员工信息
SELECT * FROM employees WHERE hiredate = '1992-4-3';

SELECT * FROM employees WHERE hiredate = STR_TO_DATE('4-3 1992','%c-%d %Y');


#date_format 将日期转换成字符
SELECT DATE_FORMAT(NOW(),'%y年%m月%d日') AS out_put;

#查询有奖金的员工名和入职日期(xx月/xx日 xx年)
SELECT last_name,DATE_FORMAT(hiredate,'%m月/%d日 %y年') 入职日期
FROM employees
WHERE commission_pct IS NOT NULL;

```

##### 4-4 其他函数

```sql
SELECT VERSION();
SELECT DATABASE();
SELECT USER();
```

##### 4-5 流程控制函数

###### 5-1 if 函数

```sql
#1.if函数： if else 的效果

SELECT IF(10<5,'大','小');

SELECT last_name,commission_pct,IF(commission_pct IS NULL,'没奖金，呵呵','有奖金，嘻嘻') 备注
FROM employees;
```

###### 5-2 case 函数的使用

```sql
/*
case 要判断的字段或表达式
when 常量1 then 要显示的值1或语句1;
when 常量2 then 要显示的值2或语句2;
...
else 要显示的值n或语句n;
end
*/

/*案例：查询员工的工资，要求

部门号=30，显示的工资为1.1倍
部门号=40，显示的工资为1.2倍
部门号=50，显示的工资为1.3倍
其他部门，显示的工资为原工资

*/

SELECT salary 原始工资,department_id,
CASE department_id
WHEN 30 THEN salary*1.1
WHEN 40 THEN salary*1.2
WHEN 50 THEN salary*1.3
ELSE salary
END AS 新工资
FROM employees;



#3.case 函数的使用二：类似于 多重if
/*
case
when 条件1 then 要显示的值1或语句1
when 条件2 then 要显示的值2或语句2
。。。
else 要显示的值n或语句n
end
*/

#案例：查询员工的工资的情况
/*
如果工资>20000,显示A级别
如果工资>15000,显示B级别
如果工资>10000，显示C级别
否则，显示D级别
*/

SELECT salary,
CASE
WHEN salary>20000 THEN 'A'
WHEN salary>15000 THEN 'B'
WHEN salary>10000 THEN 'C'
ELSE 'D'
END AS 工资级别
FROM employees;
```

##### 4-6 分组函数

```sql
/*
功能：用作统计使用，又称为聚合函数或统计函数或组函数
分类：
sum 求和、avg 平均值、max 最大值 、min 最小值 、count 计算个数

特点：
1、sum、avg一般用于处理数值型
   max、min、count可以处理任何类型
2、以上分组函数都忽略null值
3、可以和distinct搭配实现去重的运算
4、count函数的单独介绍
一般使用count(*)用作统计行数
5、和分组函数一同查询的字段要求是group by后的字段
*/
```

###### 6-1 简单的使用

```sql
SELECT SUM(salary) FROM employees;
SELECT AVG(salary) FROM employees;
SELECT MIN(salary) FROM employees;
SELECT MAX(salary) FROM employees;
SELECT COUNT(salary) FROM employees;

SELECT SUM(salary) 和,AVG(salary) 平均,MAX(salary) 最高,MIN(salary) 最低,COUNT(salary) 个数
FROM employees;

SELECT SUM(salary) 和,ROUND(AVG(salary),2) 平均,MAX(salary) 最高,MIN(salary) 低,COUNT(salary) 个数
FROM employees;

```

###### 6-2 参数支持那些类型

```sql
SELECT SUM(last_name) ,AVG(last_name) FROM employees;
SELECT SUM(hiredate) ,AVG(hiredate) FROM employees;

SELECT MAX(last_name),MIN(last_name) FROM employees;

SELECT MAX(hiredate),MIN(hiredate) FROM employees;

SELECT COUNT(commission_pct) FROM employees;
SELECT COUNT(last_name) FROM employees;
```

###### 6-3 能否忽略 null

```sql
SELECT
SUM(commission_pct),
AVG(commission_pct),
SUM(commission_pct)/35,
SUM(commission_pct)/107
FROM employees;

SELECT MAX(commission_pct) ,MIN(commission_pct) FROM employees;

SELECT COUNT(commission_pct) FROM employees;
SELECT commission_pct FROM employees;
```

###### 6-3 和 distinct 搭配

```sql
SELECT SUM(DISTINCT salary),SUM(salary) FROM employees;

SELECT COUNT(DISTINCT salary),COUNT(salary) FROM employees;
```

###### 6-5 count 函数的详细介绍

```sql
SELECT COUNT(salary) FROM employees;

SELECT COUNT(*) FROM employees;

SELECT COUNT(1) FROM employees;

效率：
## MYISAM存储引擎下  ，COUNT(*)的效率高
## INNODB 存储引擎下，COUNT(*)和COUNT(1)的效率差不多，比COUNT(字段)要高一些
```

###### 6-6 和分组函数一同查询的字段有限制

```sql
SELECT AVG(salary),employee_id  FROM employees;
```

###### 6-7 datediff 函数

```SQL
## 返回两个日期相差的天数
select datediff('2017-10-1','2017-05-18');
select datediff(max(hiredate),min(hiredate)) from employees;
```

#### 1.2.5 进阶 5：分组查询

```sql
/*
语法：
select 查询列表
from 表
【where 筛选条件】
group by 分组的字段
【order by 排序的字段】;

特点：
1、和分组函数一同查询的字段必须是group by后出现的字段
2、筛选分为两类：分组前筛选和分组后筛选
        针对的表			位置		连接的关键字
分组前筛选	原始表				group by前	where

分组后筛选	group by后的结果集    		group by后	having

问题1：分组函数做筛选能不能放在where后面
答：不能

问题2：where——group by——having

一般来讲，能用分组前筛选的，尽量使用分组前筛选，提高效率

3、分组可以按单个字段也可以按多个字段
4、可以搭配着排序使用
*/
```

##### 5-1 简单的分组

```sql
#案例1：查询每个工种的员工平均工资
SELECT AVG(salary),job_id
FROM employees
GROUP BY job_id;

#案例2：查询每个位置的部门个数
SELECT COUNT(*),location_id
FROM departments
GROUP BY location_id;
```

##### 5-2 分组前筛选

```sql
#案例1：查询邮箱中包含a字符的 每个部门的最高工资
SELECT MAX(salary),department_id
FROM employees
WHERE email LIKE '%a%'
GROUP BY department_id;

#案例2：查询有奖金的每个领导手下员工的平均工资
SELECT AVG(salary),manager_id
FROM employees
WHERE commission_pct IS NOT NULL
GROUP BY manager_id;
```

##### 5-3 分组后筛选

```sql
#案例：查询哪个部门的员工个数>5
# ①查询每个部门的员工个数
SELECT COUNT(*),department_id
FROM employees
GROUP BY department_id;
#② 筛选刚才①结果
SELECT COUNT(*),department_id
FROM employees
GROUP BY department_id
HAVING COUNT(*)>5;


#案例2：每个工种有奖金的员工的最高工资>12000的工种编号和最高工资
SELECT job_id,MAX(salary)
FROM employees
WHERE commission_pct IS NOT NULL
GROUP BY job_id
HAVING MAX(salary)>12000;

#案例3：领导编号>102的每个领导手下的最低工资大于5000的领导编号和最低工资

manager_id>102

SELECT manager_id,MIN(salary)
FROM employees
GROUP BY manager_id
HAVING MIN(salary)>5000;
```

##### 5-4 添加排序

```sql
#案例：每个工种有奖金的员工的最高工资>6000的工种编号和最高工资,按最高工资升序

SELECT job_id,MAX(salary) m
FROM employees
WHERE commission_pct IS NOT NULL
GROUP BY job_id
HAVING m>6000
ORDER BY m ;

```

##### 5-5 按多个字段分组

```sql
#案例：查询每个工种每个部门的最低工资,并按最低工资降序

SELECT MIN(salary),job_id,department_id
FROM employees
GROUP BY department_id,job_id
ORDER BY MIN(salary) DESC;
```

#### 1.2.6 进阶 6：连接查询

```sql
/*
含义：又称多表查询，当查询的字段来自于多个表时，就会用到连接查询

笛卡尔乘积现象：表1 有m行，表2有n行，结果=m*n行

发生原因：没有有效的连接条件
如何避免：添加有效的连接条件

分类：
    按年代分类：
    sql92标准:仅仅支持内连接
    sql99标准【推荐】：支持内连接+外连接（左外和右外）+交叉连接

    按功能分类：
        内连接：
            等值连接
            非等值连接
            自连接
        外连接：
            左外连接
            右外连接
            全外连接
        交叉连接
*/
```

##### 6-1 sql92 标准

###### 1-1 等值连接

```SQL
/*
① 多表等值连接的结果为多表的交集部分
② n表连接，至少需要n-1个连接条件
③ 多表的顺序没有要求
④ 一般需要为表起别名
⑤ 可以搭配前面介绍的所有子句使用，比如排序、分组、筛选

*/

#案例1：查询女神名和对应的男神名
SELECT name,boyName
FROM boys,beauty
WHERE beauty.boyfriend_id= boys.id;

#案例2：查询员工名和对应的部门名
SELECT last_name,department_name
FROM employees,departments
WHERE employees.`department_id`=departments.`department_id`;
```

###### 1-2 给表起别名

```sql
/*
①提高语句的简洁度
②区分多个重名的字段
注意：
    如果为表起了别名，则查询的字段就不能使用原来的表名去限定，
    两个表的顺序可以改变
*/
#查询员工名、工种号、工种名

SELECT e.last_name,e.job_id,j.job_title
FROM employees  e,jobs j
WHERE e.`job_id`=j.`job_id`;
```

###### 1-3 两个表顺序调换

```sql
#查询员工名、工种号、工种名

SELECT e.last_name,e.job_id,j.job_title
FROM jobs j,employees e
WHERE e.`job_id`=j.`job_id`;
```

###### 1-4 可以加筛选

```sql
#案例：查询有奖金的员工名、部门名
SELECT last_name,department_name,commission_pct
FROM employees e,departments d
WHERE e.`department_id`=d.`department_id`
AND e.`commission_pct` IS NOT NULL;

#案例2：查询城市名中第二个字符为o的部门名和城市名
SELECT department_name,city
FROM departments d,locations l
WHERE d.`location_id` = l.`location_id`
AND city LIKE '_o%';
```

###### 1-5 可以加分组

```sql
#案例1：查询每个城市的部门个数
SELECT COUNT(*) 个数,city
FROM departments d,locations l
WHERE d.`location_id`=l.`location_id`
GROUP BY city;


#案例2：查询有奖金的每个部门的部门名和部门的领导编号和该部门的最低工资
SELECT department_name,d.`manager_id`,MIN(salary)
FROM departments d,employees e
WHERE d.`department_id`=e.`department_id`
AND commission_pct IS NOT NULL
GROUP BY department_name,d.`manager_id`;
```

###### 1-6 可以加排序

```sql
#案例：查询每个工种的工种名和员工的个数，并且按员工个数降序
SELECT job_title,COUNT(*)
FROM employees e,jobs j
WHERE e.`job_id`=j.`job_id`
GROUP BY job_title
ORDER BY COUNT(*) DESC;

```

###### 1-7 三表连接

```sql
#案例：查询员工名、部门名和所在的城市
SELECT last_name,department_name,city
FROM employees e,departments d,locations l
WHERE e.`department_id`=d.`department_id`
AND d.`location_id`=l.`location_id`
AND city LIKE 's%'
ORDER BY department_name DESC;

```

###### 1-8 非等值连接

```sql
#案例1：查询员工的工资和工资级别


SELECT salary,grade_level
FROM employees e,job_grades g
WHERE salary BETWEEN g.`lowest_sal` AND g.`highest_sal`
AND g.`grade_level`='A';

/*
select salary,employee_id from employees;
select * from job_grades;
CREATE TABLE job_grades
(grade_level VARCHAR(3),
 lowest_sal  int,
 highest_sal int);

INSERT INTO job_grades
VALUES ('A', 1000, 2999);

INSERT INTO job_grades
VALUES ('B', 3000, 5999);

INSERT INTO job_grades
VALUES('C', 6000, 9999);

INSERT INTO job_grades
VALUES('D', 10000, 14999);

INSERT INTO job_grades
VALUES('E', 15000, 24999);

INSERT INTO job_grades
VALUES('F', 25000, 40000);

*/
```

###### 1-9 自连接

```sql
#案例：查询 员工名和上级的名称
SELECT e.employee_id,e.last_name,m.employee_id,m.last_name
FROM employees e,employees m
WHERE e.`manager_id`=m.`employee_id`;

## 自连接就是把一张表用两次来查询数据
```

###### 1-10 案例讲解

```sql
## 单行函数
    #1.	显示系统时间(注：日期+时间)
    SELECT NOW();

    #2.	查询员工号，姓名，工资，以及工资提高百分之20%后的结果（new salary）
    SELECT employee_id,last_name,salary,salary*1.2 "new salary"
    FROM employees;
    #3.	将员工的姓名按首字母排序，并写出姓名的长度（length）
    SELECT LENGTH(last_name) 长度,SUBSTR(last_name,1,1) 首字符,last_name
    FROM employees
    ORDER BY 首字符;

    #4.	做一个查询，产生下面的结果
    <last_name> earns <salary> monthly but wants <salary*3>
    Dream Salary
    King earns 24000 monthly but wants 72000

    SELECT CONCAT(last_name,' earns ',salary,' monthly but wants ',salary*3) AS "Dream 			Salary"
    FROM employees
    WHERE salary=24000;

    #5.	使用case-when，按照下面的条件：
    job                  grade
    AD_PRES            A
    ST_MAN             B
    IT_PROG             C
    SA_REP              D
    ST_CLERK           E
    产生下面的结果
    Last_name	Job_id	Grade
    king	AD_PRES	A

    SELECT last_name,job_id AS  job,
    CASE job_id
    WHEN 'AD_PRES' THEN 'A'
    WHEN 'ST_MAN' THEN 'B'
    WHEN 'IT_PROG' THEN 'C'
    WHEN 'SA_PRE' THEN 'D'
    WHEN 'ST_CLERK' THEN 'E'
    END AS Grade
    FROM employees
    WHERE job_id = 'AD_PRES';

#分组查询
    #1.查询各job_id的员工工资的最大值，最小值，平均值，总和，并按job_id升序
    SELECT MAX(salary),MIN(salary),AVG(salary),SUM(salary),job_id
    FROM employees
    GROUP BY job_id
    ORDER BY job_id;


    #2.查询员工最高工资和最低工资的差距（DIFFERENCE）
    SELECT MAX(salary)-MIN(salary) DIFFRENCE
    FROM employees;

    #3.查询各个管理者手下员工的最低工资，其中最低工资不能低于6000，没有管理者的员工不计算在内
    SELECT MIN(salary),manager_id
    FROM employees
    WHERE manager_id IS NOT NULL
    GROUP BY manager_id
    HAVING MIN(salary)>=6000;

    #4.查询所有部门的编号，员工数量和工资平均值,并按平均工资降序
    SELECT department_id,COUNT(*),AVG(salary) a
    FROM employees
    GROUP BY department_id
    ORDER BY a DESC;

    #5.选择具有各个job_id的员工人数
    SELECT COUNT(*) 个数,job_id
    FROM employees
    GROUP BY job_id;

## 排序查询
    #1.查询员工的姓名和部门号和年薪，按年薪降序 按姓名升序
    SELECT last_name,department_id,salary*12*(1+IFNULL(commission_pct,0)) 年薪
    FROM employees
    ORDER BY 年薪 DESC,last_name ASC;


    #2.选择工资不在8000到17000的员工的姓名和工资，按工资降序
    SELECT last_name,salary
    FROM employees
    WHERE salary NOT BETWEEN 8000 AND 17000
    ORDER BY salary DESC;

    #3.查询邮箱中包含e的员工信息，并先按邮箱的字节数降序，再按部门号升序
    SELECT *,LENGTH(email)
    FROM employees
    WHERE email LIKE '%e%'
    ORDER BY LENGTH(email) DESC,department_id ASC;


# 分组函数
    #1.查询公司员工工资的最大值，最小值，平均值，总和
    SELECT MAX(salary) 最大值,MIN(salary) 最小值,AVG(salary) 平均值,SUM(salary) 和
    FROM employees;

    #2.查询员工表中的最大入职时间和最小入职时间的相差天数 （DIFFRENCE）
    SELECT MAX(hiredate) 最大,MIN(hiredate) 最小,(MAX(hiredate)-MIN(hiredate))/1000/3600/24 DIFFRENCE
    FROM employees;
    SELECT DATEDIFF(MAX(hiredate),MIN(hiredate)) DIFFRENCE
    FROM employees;
    SELECT DATEDIFF('1995-2-7','1995-2-6');


    #3.查询部门编号为90的员工个数
    SELECT COUNT(*) FROM employees WHERE department_id = 90;
```

##### 6-2 sql99 语法

```sql
/*
语法：
    select 查询列表
    from 表1 别名 【连接类型】
    join 表2 别名
    on 连接条件
    【where 筛选条件】
    【group by 分组】
    【having 筛选条件】
    【order by 排序列表】

分类：
内连接（★）：inner
外连接
    左外(★):left 【outer】
    右外(★)：right 【outer】
    全外：full【outer】
交叉连接：cross
*/

```

###### 2-1 内连接

```sql
/*
语法：
select 查询列表
from 表1 别名
inner join 表2 别名
on 连接条件;

分类：
等值
非等值
自连接

特点：
①添加排序、分组、筛选
②inner可以省略
③ 筛选条件放在where后面，连接条件放在on后面，提高分离性，便于阅读
④inner join连接和sql92语法中的等值连接效果是一样的，都是查询多表的交集
*/
```

###### 2-2 等值连接

```sql
#案例1.查询员工名、部门名
SELECT last_name,department_name
FROM departments d
 JOIN  employees e
ON e.`department_id` = d.`department_id`;



#案例2.查询名字中包含e的员工名和工种名（添加筛选）
    SELECT last_name,job_title
    FROM employees e
    INNER JOIN jobs j
    ON e.`job_id`=  j.`job_id`
    WHERE e.`last_name` LIKE '%e%';



#3. 查询部门个数>3的城市名和部门个数，（添加分组+筛选）
    #①查询每个城市的部门个数
    #②在①结果上筛选满足条件的
    SELECT city,COUNT(*) 部门个数
    FROM departments d
    INNER JOIN locations l
    ON d.`location_id`=l.`location_id`
    GROUP BY city
    HAVING COUNT(*)>3;




#案例4.查询哪个部门的员工个数>3的部门名和员工个数，并按个数降序（添加排序）
    #①查询每个部门的员工个数
    SELECT COUNT(*),department_name
    FROM employees e
    INNER JOIN departments d
    ON e.`department_id`=d.`department_id`
    GROUP BY department_name

    #② 在①结果上筛选员工个数>3的记录，并排序
    SELECT COUNT(*) 个数,department_name
    FROM employees e
    INNER JOIN departments d
    ON e.`department_id`=d.`department_id`
    GROUP BY department_name
    HAVING COUNT(*)>3
    ORDER BY COUNT(*) DESC;

#5.查询员工名、部门名、工种名，并按部门名降序（添加三表连接）
SELECT last_name,department_name,job_title
FROM employees e
INNER JOIN departments d ON e.`department_id`=d.`department_id`
INNER JOIN jobs j ON e.`job_id` = j.`job_id`
ORDER BY department_name DESC;

```

###### 2-3 非等值连接

```sql
#查询员工的工资级别
SELECT salary,grade_level
FROM employees e
 JOIN job_grades g
 ON e.`salary` BETWEEN g.`lowest_sal` AND g.`highest_sal`;


 #查询工资级别的个数>20的个数，并且按工资级别降序
 SELECT COUNT(*),grade_level
FROM employees e
 JOIN job_grades g
 ON e.`salary` BETWEEN g.`lowest_sal` AND g.`highest_sal`
 GROUP BY grade_level
 HAVING COUNT(*)>20
 ORDER BY grade_level DESC;
```

###### 2-4 自连接

```sql
 #查询员工的名字、上级的名字
 SELECT e.last_name,m.last_name
 FROM employees e
 JOIN employees m
 ON e.`manager_id`= m.`employee_id`;

  #查询姓名中包含字符k的员工的名字、上级的名字
 SELECT e.last_name,m.last_name
 FROM employees e
 JOIN employees m
 ON e.`manager_id`= m.`employee_id`
 WHERE e.`last_name` LIKE '%k%';
```

###### 2-5 外连接

```sql
 /*
 应用场景：用于查询一个表中有，另一个表没有的记录

 特点：
 1、外连接的查询结果为主表中的所有记录
    如果从表中有和它匹配的，则显示匹配的值
    如果从表中没有和它匹配的，则显示null
    外连接查询结果=内连接结果+主表中有而从表没有的记录
 2、左外连接，left join左边的是主表
    右外连接，right join右边的是主表
 3、左外和右外交换两个表的顺序，可以实现同样的效果
 4、全外连接=内连接的结果+表1中有但表2没有的+表2中有但表1没有的
 */
 #引入：查询男朋友 不在男神表的的女神名

 SELECT * FROM beauty;
 SELECT * FROM boys;
```

###### 2-6 左外连接

```sql
 SELECT b.*,bo.*
 FROM boys bo
 LEFT OUTER JOIN beauty b
 ON b.`boyfriend_id` = bo.`id`
 WHERE b.`id` IS NULL;


 #案例1：查询哪个部门没有员工
 #左外
 SELECT d.*,e.employee_id
 FROM departments d
 LEFT OUTER JOIN employees e
 ON d.`department_id` = e.`department_id`
 WHERE e.`employee_id` IS NULL;
```

###### 2-7 右外连接

```sql
  SELECT d.*,e.employee_id
 FROM employees e
 RIGHT OUTER JOIN departments d
 ON d.`department_id` = e.`department_id`
 WHERE e.`employee_id` IS NULL;
```

###### 2-8 全连接

```sql
 USE girls;
 SELECT b.*,bo.*
 FROM beauty b
 FULL OUTER JOIN boys bo
 ON b.`boyfriend_id` = bo.id;
```

###### 2-9 交叉连接

```sql
 SELECT b.*,bo.*
 FROM beauty b
 CROSS JOIN boys bo;
```

###### 2-10 sql92 和 slq99pk

```sql
 #sql92和 sql99pk
 /*
 功能：sql99支持的较多
 可读性：sql99实现连接条件和筛选条件的分离，可读性较高
 */
```

###### 2-11 案例练习

```sql
## 连接查询
#1.显示所有员工的姓名，部门号和部门名称。
USE myemployees;

SELECT last_name,d.department_id,department_name
FROM employees e,departments d
WHERE e.`department_id` = d.`department_id`;

#2.查询90号部门员工的job_id和90号部门的location_id
SELECT job_id,location_id
FROM employees e,departments d
WHERE e.`department_id`=d.`department_id`
AND e.`department_id`=90;

#3.	选择所有有奖金的员工的
last_name , department_name , location_id , city

SELECT last_name , department_name , l.location_id , city
FROM employees e,departments d,locations l
WHERE e.department_id = d.department_id
AND d.location_id=l.location_id
AND e.commission_pct IS NOT NULL;
#4.选择city在Toronto工作的员工的
last_name , job_id , department_id , department_name

SELECT last_name , job_id , d.department_id , department_name
FROM employees e,departments d ,locations l
WHERE e.department_id = d.department_id
AND d.location_id=l.location_id
AND city = 'Toronto';

#5.查询每个工种、每个部门的部门名、工种名和最低工资
SELECT department_name,job_title,MIN(salary) 最低工资
FROM employees e,departments d,jobs j
WHERE e.`department_id`=d.`department_id`
AND e.`job_id`=j.`job_id`
GROUP BY department_name,job_title;

#6.查询每个国家下的部门个数大于2的国家编号
SELECT country_id,COUNT(*) 部门个数
FROM departments d,locations l
WHERE d.`location_id`=l.`location_id`
GROUP BY country_id
HAVING 部门个数>2;

#7、选择指定员工的姓名，员工号，以及他的管理者的姓名和员工号，结果类似于下面的格式
employees	Emp#	manager	Mgr#
kochhar		101	king	100

SELECT e.last_name employees,e.employee_id "Emp#",m.last_name manager,m.employee_id "Mgr#"
FROM employees e,employees m
WHERE e.manager_id = m.employee_id
AND e.last_name='kochhar';


## 外连接


#一、查询编号>3的女神的男朋友信息，如果有则列出详细，如果没有，用null填充
SELECT b.id,b.name,bo.*
FROM beauty b
LEFT OUTER JOIN boys bo
ON b.`boyfriend_id` = bo.`id`
WHERE b.`id`>3;

#二、查询哪个城市没有部门
SELECT city
FROM departments d
RIGHT OUTER JOIN locations l
ON d.`location_id`=l.`location_id`
WHERE  d.`department_id` IS NULL;

#三、查询部门名为SAL或IT的员工信息
SELECT e.*,d.department_name,d.`department_id`
FROM departments  d
LEFT JOIN employees e
ON d.`department_id` = e.`department_id`
WHERE d.`department_name` IN('SAL','IT');

SELECT * FROM departments
WHERE `department_name` IN('SAL','IT');

## 子查询
#1.	查询和Zlotkey相同部门的员工姓名和工资
    #①查询Zlotkey的部门
    SELECT department_id
    FROM employees
    WHERE last_name = 'Zlotkey'
    #②查询部门号=①的姓名和工资
    SELECT last_name,salary
    FROM employees
    WHERE department_id = (
        SELECT department_id
        FROM employees
        WHERE last_name = 'Zlotkey'
    )

#2.查询工资比公司平均工资高的员工的员工号，姓名和工资。
    #①查询平均工资
    SELECT AVG(salary)
    FROM employees
    #②查询工资>①的员工号，姓名和工资。
    SELECT last_name,employee_id,salary
    FROM employees
    WHERE salary>(
        SELECT AVG(salary)
        FROM employees
    );



#3.查询各部门中工资比本部门平均工资高的员工的员工号, 姓名和工资
    #①查询各部门的平均工资
    SELECT AVG(salary),department_id
    FROM employees
    GROUP BY department_id

    #②连接①结果集和employees表，进行筛选
    SELECT employee_id,last_name,salary,e.department_id
    FROM employees e
    INNER JOIN (
        SELECT AVG(salary) ag,department_id
        FROM employees
        GROUP BY department_id
    ) ag_dep
    ON e.department_id = ag_dep.department_id
    WHERE salary>ag_dep.ag ;



#4.	查询和姓名中包含字母u的员工在相同部门的员工的员工号和姓名
    #①查询姓名中包含字母u的员工的部门
    SELECT  DISTINCT department_id
    FROM employees
    WHERE last_name LIKE '%u%'
    #②查询部门号=①中的任意一个的员工号和姓名
    SELECT last_name,employee_id
    FROM employees
    WHERE department_id IN(
        SELECT  DISTINCT department_id
        FROM employees
        WHERE last_name LIKE '%u%'
    );


#5. 查询在部门的location_id为1700的部门工作的员工的员工号
    #①查询location_id为1700的部门
    SELECT DISTINCT department_id
    FROM departments
    WHERE location_id  = 1700

    #②查询部门号=①中的任意一个的员工号
    SELECT employee_id
    FROM employees
    WHERE department_id =ANY(
        SELECT DISTINCT department_id
        FROM departments
        WHERE location_id  = 1700
    );
#6.查询管理者是King的员工姓名和工资
    #①查询姓名为king的员工编号
    SELECT employee_id
    FROM employees
    WHERE last_name  = 'K_ing'

    #②查询哪个员工的manager_id = ①
    SELECT last_name,salary
    FROM employees
    WHERE manager_id IN(
        SELECT employee_id
        FROM employees
        WHERE last_name  = 'K_ing'
    );

#7.查询工资最高的员工的姓名，要求first_name和last_name显示为一列，列名为 姓.名
    #①查询最高工资
    SELECT MAX(salary)
    FROM employees
    #②查询工资=①的姓.名
    SELECT CONCAT(first_name,last_name) "姓.名"
    FROM employees
    WHERE salary=(
        SELECT MAX(salary)
        FROM employees
    );

```

#### 1.2.7 进阶 7：子查询

```sql
/*
含义：
出现在其他语句中的select语句，称为子查询或内查询
外部的查询语句，称为主查询或外查询

分类：
按子查询出现的位置：
    select后面：
        仅仅支持标量子查询

    from后面：
        支持表子查询
    where或having后面：★
        标量子查询（单行） √
        列子查询  （多行） √
        行子查询

    exists后面（相关子查询）
        表子查询
按结果集的行列数不同：
    标量子查询（结果集只有一行一列）
    列子查询（结果集只有一列多行）
    行子查询（结果集有一行多列）
    表子查询（结果集一般为多行多列）
*/
```

##### 7-1 where 或 having 后面

```sql
/*
1、标量子查询（单行子查询）
2、列子查询（多行子查询）
3、行子查询（多列多行）
特点：
①子查询放在小括号内
②子查询一般放在条件的右侧
③标量子查询，一般搭配着单行操作符使用
> < >= <= = <>

列子查询，一般搭配着多行操作符使用
in、any/some、all
④子查询的执行优先于主查询执行，主查询的条件用到了子查询的结果

*/
```

###### 1-1 标量子查询

```sql
#案例1：谁的工资比 Abel 高?
    #①查询Abel的工资
    SELECT salary
    FROM employees
    WHERE last_name = 'Abel'
    #②查询员工的信息，满足 salary>①结果
    SELECT *
    FROM employees
    WHERE salary>(

        SELECT salary
        FROM employees
        WHERE last_name = 'Abel'
    );

#案例2：返回job_id与141号员工相同，salary比143号员工多的员工 姓名，job_id 和工资
    #①查询141号员工的job_id
    SELECT job_id
    FROM employees
    WHERE employee_id = 141
    #②查询143号员工的salary
    SELECT salary
    FROM employees
    WHERE employee_id = 143

    #③查询员工的姓名，job_id 和工资，要求job_id=①并且salary>②
    SELECT last_name,job_id,salary
    FROM employees
    WHERE job_id = (
        SELECT job_id
        FROM employees
        WHERE employee_id = 141
    ) AND salary>(
        SELECT salary
        FROM employees
        WHERE employee_id = 143
    );


#案例3：返回公司工资最少的员工的last_name,job_id和salary
    #①查询公司的 最低工资
    SELECT MIN(salary)
    FROM employees
    #②查询last_name,job_id和salary，要求salary=①
    SELECT last_name,job_id,salary
    FROM employees
    WHERE salary=(
        SELECT MIN(salary)
        FROM employees
    );


#案例4：查询最低工资大于50号部门最低工资的部门id和其最低工资
    #①查询50号部门的最低工资
    SELECT  MIN(salary)
    FROM employees
    WHERE department_id = 50
    #②查询每个部门的最低工资
    SELECT MIN(salary),department_id
    FROM employees
    GROUP BY department_id

#③ 在②基础上筛选，满足min(salary)>①
    SELECT MIN(salary),department_id
    FROM employees
    GROUP BY department_id
    HAVING MIN(salary)>(
        SELECT  MIN(salary)
        FROM employees
        WHERE department_id = 50
    );

#非法使用标量子查询
    SELECT MIN(salary),department_id
    FROM employees
    GROUP BY department_id
    HAVING MIN(salary)>(
        SELECT  salary
        FROM employees
        WHERE department_id = 250
    );
```

###### 1-2 列子查询

```sql
#案例1：返回location_id是1400或1700的部门中的所有员工姓名
    #①查询location_id是1400或1700的部门编号
    SELECT DISTINCT department_id
    FROM departments
    WHERE location_id IN(1400,1700)
    #②查询员工姓名，要求部门号是①列表中的某一个

    SELECT last_name
    FROM employees
    WHERE department_id  <>ALL(
        SELECT DISTINCT department_id
        FROM departments
        WHERE location_id IN(1400,1700)
    );


#案例2：返回其它工种中比job_id为‘IT_PROG’工种任一工资低的员工的员工号、姓名、job_id 以及salary
    #①查询job_id为‘IT_PROG’部门任一工资
    SELECT DISTINCT salary
    FROM employees
    WHERE job_id = 'IT_PROG'
    #②查询员工号、姓名、job_id 以及salary，salary<(①)的任意一个
    SELECT last_name,employee_id,job_id,salary
    FROM employees
    WHERE salary<ANY(
        SELECT DISTINCT salary
        FROM employees
        WHERE job_id = 'IT_PROG'
    ) AND job_id<>'IT_PROG';

#或
    SELECT last_name,employee_id,job_id,salary
    FROM employees
    WHERE salary<(
        SELECT MAX(salary)
        FROM employees
        WHERE job_id = 'IT_PROG'

    ) AND job_id<>'IT_PROG';


#案例3：返回其它部门中比job_id为‘IT_PROG’部门所有工资都低的员工   的员工号、姓名、job_id 以及salary
    SELECT last_name,employee_id,job_id,salary
    FROM employees
    WHERE salary<ALL(
        SELECT DISTINCT salary
        FROM employees
        WHERE job_id = 'IT_PROG'

    ) AND job_id<>'IT_PROG';

#或

    SELECT last_name,employee_id,job_id,salary
    FROM employees
    WHERE salary<(
        SELECT MIN( salary)
        FROM employees
        WHERE job_id = 'IT_PROG'

    ) AND job_id<>'IT_PROG';

```

###### 1-3 行子查询

```sql
##行子查询（结果集一行多列或多行多列）

#案例：查询员工编号最小并且工资最高的员工信息
SELECT *
FROM employees
WHERE (employee_id,salary)=(
    SELECT MIN(employee_id),MAX(salary)
    FROM employees
);

    #①查询最小的员工编号
    SELECT MIN(employee_id)
    FROM employees
    #②查询最高工资
    SELECT MAX(salary)
    FROM employees
    #③查询员工信息
    SELECT *
    FROM employees
    WHERE employee_id=(
        SELECT MIN(employee_id)
        FROM employees
    )AND salary=(
        SELECT MAX(salary)
        FROM employees
    );
```

##### 7-2 select 后面

```sql
/*
仅仅支持标量子查询
*/

#案例：查询每个部门的员工个数
SELECT d.*,(

    SELECT COUNT(*)
    FROM employees e
    WHERE e.department_id = d.`department_id`
 ) 个数
 FROM departments d;


 #案例2：查询员工号=102的部门名
SELECT (
    SELECT department_name,e.department_id
    FROM departments d
    INNER JOIN employees e
    ON d.department_id=e.department_id
    WHERE e.employee_id=102
) 部门名;

```

##### 7-3 from 后面

```sql
/*
将子查询结果充当一张表，要求必须起别名
*/

#案例：查询每个部门的平均工资的工资等级
#①查询每个部门的平均工资
SELECT AVG(salary),department_id
FROM employees
GROUP BY department_id
SELECT * FROM job_grades;

#②连接①的结果集和job_grades表，筛选条件平均工资 between lowest_sal and highest_sal

SELECT  ag_dep.*,g.`grade_level`
FROM (
    SELECT AVG(salary) ag,department_id
    FROM employees
    GROUP BY department_id
) ag_dep
INNER JOIN job_grades g
ON ag_dep.ag BETWEEN lowest_sal AND highest_sal;

```

##### 7-4 exists 后面

```sql
#四、exists后面（相关子查询）

/*
语法：
exists(完整的查询语句)
结果：
1或0
*/

SELECT EXISTS(SELECT employee_id FROM employees WHERE salary=300000);

#案例1：查询有员工的部门名
#in
SELECT department_name
FROM departments d
WHERE d.`department_id` IN(
    SELECT department_id
    FROM employees
)

#exists
SELECT department_name
FROM departments d
WHERE EXISTS(
    SELECT *
    FROM employees e
    WHERE d.`department_id`=e.`department_id`
);


#案例2：查询没有女朋友的男神信息
#in
SELECT bo.*
FROM boys bo
WHERE bo.id NOT IN(
    SELECT boyfriend_id
    FROM beauty
)

#exists
SELECT bo.*
FROM boys bo
WHERE NOT EXISTS(
    SELECT boyfriend_id
    FROM beauty b
    WHERE bo.`id`=b.`boyfriend_id`
);

```

#### 1.2.8 进阶 8：分页查询

```sql
/*
应用场景：当要显示的数据，一页显示不全，需要分页提交sql请求
语法：
    select 查询列表
    from 表
    【join type join 表2
    on 连接条件
    where 筛选条件
    group by 分组字段
    having 分组后的筛选
    order by 排序的字段】
    limit 【offset,】size;

    offset要显示条目的起始索引（起始索引从0开始）
    size 要显示的条目个数
特点：
    ①limit语句放在查询语句的最后
    ②公式
    要显示的页数 page，每页的条目数size

    select 查询列表
    from 表
    limit (page-1)*size,size;
    size=10
    page
    1	0
    2  	10
    3	20

*/
#案例1：查询前五条员工信息
SELECT * FROM  employees LIMIT 0,5;
SELECT * FROM  employees LIMIT 5;

#案例2：查询第11条——第25条
SELECT * FROM  employees LIMIT 10,15;

#案例3：有奖金的员工信息，并且工资较高的前10名显示出来
SELECT
    *
FROM
    employees
WHERE commission_pct IS NOT NULL
ORDER BY salary DESC
LIMIT 10 ;

```

#### 1.2.9 进阶 9：联合查询

```sql
/*
union 联合 合并：将多条查询语句的结果合并成一个结果
语法：
查询语句1
union
查询语句2
union
...

应用场景：
要查询的结果来自于多个表，且多个表没有直接的连接关系，但查询的信息一致时
特点：★
1、要求多条查询语句的查询列数是一致的！
2、要求多条查询语句的查询的每一列的类型和顺序最好一致
3、union关键字默认去重，如果使用union all 可以包含重复项
*/


#引入的案例：查询部门编号>90或邮箱包含a的员工信息
SELECT * FROM employees WHERE email LIKE '%a%' OR department_id>90;;
SELECT * FROM employees  WHERE email LIKE '%a%'
UNION
SELECT * FROM employees  WHERE department_id>90;


#案例：查询中国用户中男性的信息以及外国用户中年男性的用户信息
SELECT id,cname FROM t_ca WHERE csex='男'
UNION ALL
SELECT t_id,tname FROM t_ua WHERE tGender='male';
```

#### 1.2.10 子查询经典案例

```mysql
# 1. 查询工资最低的员工信息: last_name, salary

#①查询最低的工资
SELECT MIN(salary)
FROM employees

#②查询last_name,salary，要求salary=①
SELECT last_name,salary
FROM employees
WHERE salary=(
    SELECT MIN(salary)
    FROM employees
);

# 2. 查询平均工资最低的部门信息

#方式一：
#①各部门的平均工资
SELECT AVG(salary),department_id
FROM employees
GROUP BY department_id
#②查询①结果上的最低平均工资
SELECT MIN(ag)
FROM (
    SELECT AVG(salary) ag,department_id
    FROM employees
    GROUP BY department_id
) ag_dep

#③查询哪个部门的平均工资=②

SELECT AVG(salary),department_id
FROM employees
GROUP BY department_id
HAVING AVG(salary)=(
    SELECT MIN(ag)
    FROM (
        SELECT AVG(salary) ag,department_id
        FROM employees
        GROUP BY department_id
    ) ag_dep

);

#④查询部门信息

SELECT d.*
FROM departments d
WHERE d.`department_id`=(
    SELECT department_id
    FROM employees
    GROUP BY department_id
    HAVING AVG(salary)=(
        SELECT MIN(ag)
        FROM (
            SELECT AVG(salary) ag,department_id
            FROM employees
            GROUP BY department_id
        ) ag_dep

    )

);

#方式二：
#①各部门的平均工资
SELECT AVG(salary),department_id
FROM employees
GROUP BY department_id

#②求出最低平均工资的部门编号
SELECT department_id
FROM employees
GROUP BY department_id
ORDER BY AVG(salary)
LIMIT 1;

#③查询部门信息
SELECT *
FROM departments
WHERE department_id=(
    SELECT department_id
    FROM employees
    GROUP BY department_id
    ORDER BY AVG(salary)
    LIMIT 1
);




# 3. 查询平均工资最低的部门信息和该部门的平均工资
#①各部门的平均工资
SELECT AVG(salary),department_id
FROM employees
GROUP BY department_id
#②求出最低平均工资的部门编号
SELECT AVG(salary),department_id
FROM employees
GROUP BY department_id
ORDER BY AVG(salary)
LIMIT 1;
#③查询部门信息
SELECT d.*,ag
FROM departments d
JOIN (
    SELECT AVG(salary) ag,department_id
    FROM employees
    GROUP BY department_id
    ORDER BY AVG(salary)
    LIMIT 1

) ag_dep
ON d.`department_id`=ag_dep.department_id;



# 4. 查询平均工资最高的 job 信息
#①查询最高的job的平均工资
SELECT AVG(salary),job_id
FROM employees
GROUP BY job_id
ORDER BY AVG(salary) DESC
LIMIT 1

#②查询job信息
SELECT *
FROM jobs
WHERE job_id=(
    SELECT job_id
    FROM employees
    GROUP BY job_id
    ORDER BY AVG(salary) DESC
    LIMIT 1

);
# 5. 查询平均工资高于公司平均工资的部门有哪些?

#①查询平均工资
SELECT AVG(salary)
FROM employees

#②查询每个部门的平均工资
SELECT AVG(salary),department_id
FROM employees
GROUP BY department_id

#③筛选②结果集，满足平均工资>①

SELECT AVG(salary),department_id
FROM employees
GROUP BY department_id
HAVING AVG(salary)>(
    SELECT AVG(salary)
    FROM employees

);

# 6. 查询出公司中所有 manager 的详细信息.
#①查询所有manager的员工编号
SELECT DISTINCT manager_id
FROM employees

#②查询详细信息，满足employee_id=①
SELECT *
FROM employees
WHERE employee_id =ANY(
    SELECT DISTINCT manager_id
    FROM employees

);

# 7. 各个部门中 最高工资中最低的那个部门的 最低工资是多少

#①查询各部门的最高工资中最低的部门编号
SELECT department_id
FROM employees
GROUP BY department_id
ORDER BY MAX(salary)
LIMIT 1


#②查询①结果的那个部门的最低工资

SELECT MIN(salary) ,department_id
FROM employees
WHERE department_id=(
    SELECT department_id
    FROM employees
    GROUP BY department_id
    ORDER BY MAX(salary)
    LIMIT 1


);
# 8. 查询平均工资最高的部门的 manager 的详细信息: last_name, department_id, email, salary
#①查询平均工资最高的部门编号
SELECT
    department_id
FROM
    employees
GROUP BY department_id
ORDER BY AVG(salary) DESC
LIMIT 1

#②将employees和departments连接查询，筛选条件是①
    SELECT
        last_name, d.department_id, email, salary
    FROM
        employees e
        INNER JOIN departments d
            ON d.manager_id = e.employee_id
    WHERE d.department_id =
        (SELECT
            department_id
        FROM
            employees
        GROUP BY department_id
        ORDER BY AVG(salary) DESC
        LIMIT 1) ;

```

### 1.3 DD 数据定义语言

```mysql
#DDL
/*
    数据定义语言
    库和表的管理

    一、库的管理
    创建、修改、删除
    二、表的管理
    创建、修改、删除

    创建： create
    修改： alter
    删除： drop
*/
```

#### 1.3.1 库的管理

##### 1-1 库的创建

```mysql
/*
语法：
create database  [if not exists]库名;
*/

#案例：创建库Books
CREATE DATABASE IF NOT EXISTS books ;
```

##### 1-2 库的修改

```mysql
RENAME DATABASE books TO 新库名;

#更改库的字符集
ALTER DATABASE books CHARACTER SET gbk;
```

##### 1-3 库的删除

```mysql
DROP DATABASE IF EXISTS books;
```

#### 1.3.2 表的管理

##### 2-1 表的创建

```mysql
/*
    语法：
    create table 表名(
        列名 列的类型【(长度) 约束】,
        列名 列的类型【(长度) 约束】,
        列名 列的类型【(长度) 约束】,
        ...
        列名 列的类型【(长度) 约束】
    )
*/
#案例：创建表Book
CREATE TABLE book(
    id INT,#编号
    bName VARCHAR(20),#图书名
    price DOUBLE,#价格
    authorId  INT,#作者编号
    publishDate DATETIME#出版日期
);


DESC book;

#案例：创建表author
CREATE TABLE IF NOT EXISTS author(
    id INT,
    au_name VARCHAR(20),
    nation VARCHAR(10)
)
DESC author;

```

##### 2-2 表的修改

```mysql
/*
语法
alter table 表名 add|drop|modify|change column 列名 【列类型 约束】;
*/
```

###### 2-1 修改列名

```mysql
#①修改列名
ALTER TABLE book CHANGE COLUMN publishdate pubDate DATETIME;
```

###### 2-2 修改列的类型或约束

```mysql
#②修改列的类型或约束
ALTER TABLE book MODIFY COLUMN pubdate TIMESTAMP;
```

###### 2-3 添加新列

```mysql
#③添加新列
ALTER TABLE author ADD COLUMN annual DOUBLE;
```

###### 2-4 删除列

```mysql
#④删除列
ALTER TABLE book_author DROP COLUMN  annual;
```

###### 2-5 修改表名

```mysql
#⑤修改表名
ALTER TABLE author RENAME TO book_author;
```

##### 2-3 表的删除

```mysql
DROP TABLE IF EXISTS book_author;

SHOW TABLES;

#通用的写法：
DROP DATABASE IF EXISTS 旧库名;
CREATE DATABASE 新库名;

DROP TABLE IF EXISTS 旧表名;
CREATE TABLE  表名();
```

##### 2-4 表的复制

```mysql
INSERT INTO author VALUES
(1,'村上春树','日本'),
(2,'莫言','中国'),
(3,'冯唐','中国'),
(4,'金庸','中国');

SELECT * FROM Author;
SELECT * FROM copy2;
```

###### 4-1 仅仅复制表结构

```mysql
CREATE TABLE copy LIKE author;
```

###### 4-2 复制表的结构+数据

```mysql
CREATE TABLE copy2
SELECT * FROM author;
```

###### 4-3 只复制部分数据

```mysql
CREATE TABLE copy3
SELECT id,au_name
FROM author
WHERE nation='中国';
```

###### 4-4 仅仅复制某些字段

```mysql
CREATE TABLE copy4
SELECT id,au_name
FROM author
WHERE 0;

```

#### 1.3.3 常见的数据类型

```mysql


其他：
    1，binary 和 varbinary 用于保存较短的二进制；
    2，Enum 用于保存枚举
    3，Set 用于保存集合
日期型
    1，date (4 字节) 1000-01-01 ~ 9999-12-31；
    2，datetime (8 字节)
    1000-01-01 00:00:00 ~ 9999-12-31 23:59:59；
    3，timestamp (4 字节) 1970~2038 年的某个时刻
    （受时区的影响）
    4，time 只有时间
    5，year 只有年份 1901 ~ 2155

*/
```

##### 3-1 整形

```mysql
/*
1，Tinyint（1 字节）
    有符号 -128~127
    无符号 0~255

2，Smallint（2 字节）
    有符号 -32768~32767
    无符号 0~65535

3，Mediumint（3 字节）
    有符号 -8388608~8388607
    无符号 0~1677215

4，Int，Integer（4 字节）
    有符号 -2147483648~2147483647
    无符号 0~4294967295

5，Bigint （8 字节）
反正非常非常大

特点：
① 如果不设置无符号还是有符号，默认是有符号，如果想设置无符号，需要添加unsigned关键字
② 如果插入的数值超出了整型的范围,会报out of range异常，并且插入临界值
③ 如果不设置长度，会有默认的长度
长度代表了显示的最大宽度，如果不够会用0在左边填充，但必须搭配zerofill使用！
*/
```

###### 1-1 设置无符号和有符号

```mysql
DROP TABLE IF EXISTS tab_int;
CREATE TABLE tab_int(
    t1 INT(7) ZEROFILL,
    t2 INT(7) ZEROFILL

);

DESC tab_int;

INSERT INTO tab_int VALUES(-123456);
INSERT INTO tab_int VALUES(-123456,-123456);
INSERT INTO tab_int VALUES(2147483648,4294967296);
INSERT INTO tab_int VALUES(123,123);

SELECT * FROM tab_int;
```

##### 3-2 小数

```mysql
/*
浮点型
    1，float(m,d) 4 字节
    2，Double 8 字节

定点类型
    1，Dec(m,d) m+2 字节
    2，Decimal(m,d)
 （dec,decimal 两者一样。Dec 是简写）
特点:
    1，m 是总的位数，d 是小数点后面保留的位数
    2，如果超过范围，插入的也是临界值
    3，M,d 都能省略；
    4，如果 decimal 的话 m 默认是 10，d 默认是 0；
    5，如果是 float 和 double 随着插入的数值的精度来确定精度；
    6，定点型精确度较高，如果要求插入的数值要求较高，如货币运算，则可以选择定点型；

原则：选择的类型越简单越好
*/

CREATE TABLE tab_char(
    c1 ENUM('a','b','c')


);

INSERT INTO tab_char VALUES('a');
INSERT INTO tab_char VALUES('b');
INSERT INTO tab_char VALUES('c');
INSERT INTO tab_char VALUES('m');
INSERT INTO tab_char VALUES('A');

SELECT * FROM tab_set;

CREATE TABLE tab_set(
    s1 SET('a','b','c','d')
);
INSERT INTO tab_set VALUES('a');
INSERT INTO tab_set VALUES('A,B');
INSERT INTO tab_set VALUES('a,c,d');

```

###### 2-1 测试 M 和 D

```mysql
DROP TABLE tab_float;
CREATE TABLE tab_float(
    f1 FLOAT,
    f2 DOUBLE,
    f3 DECIMAL
);
SELECT * FROM tab_float;
DESC tab_float;

INSERT INTO tab_float VALUES(123.4523,123.4523,123.4523);
INSERT INTO tab_float VALUES(123.456,123.456,123.456);
INSERT INTO tab_float VALUES(123.4,123.4,123.4);
INSERT INTO tab_float VALUES(1523.4,1523.4,1523.4);

#原则：
/*
所选择的类型越简单越好，能保存数值的类型越小越好
*/
```

##### 3-3 字符型

```mysql
/*
字符型
    1.Char(m) m 是字符数
    2.Varcahr(m)
    3.Text
    4.Blob(较大的二进制)

Char()是固定长度的字符，varcahr(m)是固定长度的字符
*/

/*
较短的文本：
char
varchar

其他：
binary和varbinary用于保存较短的二进制
enum用于保存枚举
set用于保存集合

较长的文本：
text
blob(较大的二进制)
特点：

          写法		M的意思					       特点			  空间的耗费	  效率
char	char(M)		最大的字符数，可以省略，默认为1		固定长度的字符		比较耗费	高

varchar varchar(M)	 最大的字符数，不可以省略		       可变长度的字符		比较节省	低
*/

CREATE TABLE tab_char(
    c1 ENUM('a','b','c')
);

INSERT INTO tab_char VALUES('a');
INSERT INTO tab_char VALUES('b');
INSERT INTO tab_char VALUES('c');
INSERT INTO tab_char VALUES('m');
INSERT INTO tab_char VALUES('A');

SELECT * FROM tab_set;

CREATE TABLE tab_set(
    s1 SET('a','b','c','d')
);

INSERT INTO tab_set VALUES('a');
INSERT INTO tab_set VALUES('A,B');
INSERT INTO tab_set VALUES('a,c,d');
```

##### 3-4 日期型

```mysql
/*
分类：
    date只保存日期
    time 只保存时间
    year只保存年

    datetime保存日期+时间
    timestamp保存日期+时间

特点：

          字节		   范围		时区等的影响
datetime	               8		1000——9999	                  不受
timestamp	4	                    1970-2038	                    受

*/

CREATE TABLE tab_date(
    t1 DATETIME,
    t2 TIMESTAMP

);
INSERT INTO tab_date VALUES(NOW(),NOW());

SELECT * FROM tab_date;

SHOW VARIABLES LIKE 'time_zone';

SET time_zone='+9:00';


```

#### 1.3.4 库和表的管理练习

```mysql
#1.	创建表dept1
    NAME	NULL?	TYPE
    id		INT(7)
    NAME		VARCHAR(25)

    USE test;
    CREATE TABLE dept1(
        id INT(7),
        NAME VARCHAR(25)
    );

#2.	将表departments中的数据插入新表dept2中
    CREATE TABLE dept2
    SELECT department_id,department_name
    FROM myemployees.departments;

#3.	创建表emp5
    NAME	NULL?	TYPE
    id		INT(7)
    First_name	VARCHAR (25)
    Last_name	VARCHAR(25)
    Dept_id		INT(7)

    CREATE TABLE emp5(
    id INT(7),
    first_name VARCHAR(25),
    last_name VARCHAR(25),
    dept_id INT(7)
    );


#4.	将列Last_name的长度增加到50
    ALTER TABLE emp5 MODIFY COLUMN last_name VARCHAR(50);

#5.	根据表employees创建employees2
    CREATE TABLE employees2 LIKE myemployees.employees;

#6.	删除表emp5
    DROP TABLE IF EXISTS emp5;

#7.	将表employees2重命名为emp5
    ALTER TABLE employees2 RENAME TO emp5;

#8.在表dept和emp5中添加新列test_column，并检查所作的操作
    ALTER TABLE emp5 ADD COLUMN test_column INT;

#9.直接删除表emp5中的列 dept_id
    DESC emp5;
    ALTER TABLE emp5 DROP COLUMN test_column;
```

#### 1.3.5 常见的约束

##### 5-1 分类

```mysql
/*
1. 非空约束： not null；
2. 默认约束： default；
3. 主键约束： primary key 保证字段值得唯一性，非空；
4. 为以约束： unique 保证字段值得唯一性，可以为空；
5. 检查约束： check （在 MySQL 中不支持，但不报错）；
6. 外键约束：foreign key 用于限制两个表的关系，用于保证该字段的值必须来自主表的关联列的值；在从表添加外键约束，用于引用主表中某列的值；

*/
```

##### 5-2 约束添加的分类

```mysql
## 1，列级约束：6 大约束都支持，但外键约束没有效果；
## 2，表级约束：除了非空，默认值约束，其余的都支持；
```

##### 5-3 添加约束的时机、

```mysql
## 1.创建表时
## 2.修改表时
```

##### 5-4 主键和唯一性对比

```mysql
/*
主键和唯一的大对比：

        保证唯一性  是否允许为空    一个表中可以有多少个   是否允许组合
主键	   √		 ×		       至多有1个             √，但不推荐
唯一	   √		 √		       可以有多个            √，但不推荐

外键：
    1、要求在从表设置外键关系
    2、从表的外键列的类型和主表的关联列的类型要求一致或兼容，名称无要求
    3、主表的关联列必须是一个key（一般是主键或唯一）
    4、插入数据时，先插入主表，再插入从表
    删除数据时，先删除从表，再删除主表
*/
```

##### 5-5 添加表时添加约束

###### 5-1 添加列级约束

```mysql
#1.添加列级约束
/*
语法：

直接在字段名和类型后面追加 约束类型即可。

只支持：默认、非空、主键、唯一
*/

USE students;
DROP TABLE stuinfo;
CREATE TABLE stuinfo(
    id INT PRIMARY KEY,#主键
    stuName VARCHAR(20) NOT NULL UNIQUE,#非空
    gender CHAR(1) CHECK(gender='男' OR gender ='女'),#检查
    seat INT UNIQUE,#唯一
    age INT DEFAULT  18,#默认约束
    majorId INT REFERENCES major(id)#外键
);

CREATE TABLE major(
    id INT PRIMARY KEY,
    majorName VARCHAR(20)
);

#查看stuinfo中的所有索引，包括主键、外键、唯一
SHOW INDEX FROM stuinfo;
```

###### 5-2 添加表级约束

```mysql
/*

语法：在各个字段的最下面
 【constraint 约束名】 约束类型(字段名)
*/

DROP TABLE IF EXISTS stuinfo;
CREATE TABLE stuinfo(
    id INT,
    stuname VARCHAR(20),
    gender CHAR(1),
    seat INT,
    age INT,
    majorid INT,

    CONSTRAINT pk PRIMARY KEY(id),#主键
    CONSTRAINT uq UNIQUE(seat),#唯一键
    CONSTRAINT ck CHECK(gender ='男' OR gender  = '女'),#检查
    CONSTRAINT fk_stuinfo_major FOREIGN KEY(majorid) REFERENCES major(id)#外键
);

SHOW INDEX FROM stuinfo;

#通用的写法：★
CREATE TABLE IF NOT EXISTS stuinfo(
    id INT PRIMARY KEY,
    stuname VARCHAR(20),
    sex CHAR(1),
    age INT DEFAULT 18,
    seat INT UNIQUE,
    majorid INT,
    CONSTRAINT fk_stuinfo_major FOREIGN KEY(majorid) REFERENCES major(id)
);

```

##### 5-6 修改表时添加约束

###### 6-1 添加列级约束

```mysql
alter table 表名 modify column 字段名 字段类型 新约束;
```

###### 6-2 添加表级约束

```mysql
alter table 表名 add 【constraint 约束名】 约束类型(字段名) 【外键的引用】;
```

```mysql
DROP TABLE IF EXISTS stuinfo;
CREATE TABLE stuinfo(
    id INT,
    stuname VARCHAR(20),
    gender CHAR(1),
    seat INT,
    age INT,
    majorid INT
)
DESC stuinfo;

```

###### 6-3 添加非空约束

```mysql
#1.添加非空约束
ALTER TABLE stuinfo MODIFY COLUMN stuname VARCHAR(20)  NOT NULL;
```

###### 6-4 添加默认约束

```mysql
#2.添加默认约束
ALTER TABLE stuinfo MODIFY COLUMN age INT DEFAULT 18;
```

###### 6-5 添加主键

```mysql
#①列级约束
    ALTER TABLE stuinfo MODIFY COLUMN id INT PRIMARY KEY;

#②表级约束
    ALTER TABLE stuinfo ADD PRIMARY KEY(id);
```

###### 6-6 添加唯一

```mysql
#①列级约束
    ALTER TABLE stuinfo MODIFY COLUMN seat INT UNIQUE;

#②表级约束
    ALTER TABLE stuinfo ADD UNIQUE(seat);
```

###### 6-7 添加外键

```mysql
ALTER TABLE stuinfo ADD CONSTRAINT fk_stuinfo_major FOREIGN KEY(majorid) REFERENCES major(id);
```

##### 5-6 修改表时删除约束

###### 6-1 删除非空约束

```mysql
ALTER TABLE stuinfo MODIFY COLUMN stuname VARCHAR(20) NULL;
```

###### 6-2 删除默认约束

```mysql
ALTER TABLE stuinfo MODIFY COLUMN age INT ;
```

###### 6-3 删除主键

```mysql
ALTER TABLE stuinfo DROP PRIMARY KEY;
```

###### 6-4 删除唯一

```mysql
ALTER TABLE stuinfo DROP INDEX seat;
```

###### 6-5 删除外键

```mysql
ALTER TABLE stuinfo DROP FOREIGN KEY fk_stuinfo_major;
```

#### 1.3.6 标识列

```mysql
/*
又称为自增长列
含义：可以不用手动的插入值，系统提供默认的序列值


特点：
1、标识列必须和主键搭配吗？不一定，但要求是一个key
2、一个表可以有几个标识列？至多一个！
3、标识列的类型只能是数值型
4、标识列可以通过 SET auto_increment_increment=3;设置步长
可以通过 手动插入值，设置起始值
*/

```

##### 6-1 创建表时创建标识列

```mysql
DROP TABLE IF EXISTS tab_identity;
CREATE TABLE tab_identity(
    id INT  ,
    NAME FLOAT UNIQUE AUTO_INCREMENT,
    seat INT
);

TRUNCATE TABLE tab_identity;

INSERT INTO tab_identity(id,NAME) VALUES(NULL,'john');
INSERT INTO tab_identity(NAME) VALUES('lucy');
SELECT * FROM tab_identity;

SHOW VARIABLES LIKE '%auto_increment%';

SET auto_increment_increment=3;
```

#### 1.3.7 常见约束 案例讲解

```mysql
#1.向表emp2的id列中添加PRIMARY KEY约束（my_emp_id_pk）

ALTER TABLE emp2 MODIFY COLUMN id INT PRIMARY KEY;
ALTER TABLE emp2 ADD CONSTRAINT my_emp_id_pk PRIMARY KEY(id);

#2.	向表dept2的id列中添加PRIMARY KEY约束（my_dept_id_pk）

#3.	向表emp2中添加列dept_id，并在其中定义FOREIGN KEY约束，与之相关联的列是dept2表中的id列。
ALTER TABLE emp2 ADD COLUMN dept_id INT;
ALTER TABLE emp2 ADD CONSTRAINT fk_emp2_dept2 FOREIGN KEY(dept_id) REFERENCES dept2(id);

            位置		  支持的约束类型			      是否可以起约束名
列级约束：	列的后面	 语法都支持，但外键没有效果	     不可以
表级约束：	所有列的下面	默认和非空不支持，其他支持	    可以（主键没有效果）
```

### 1.4 DML 数据操纵语言

```mysql
/*
    数据操作语言：
    插入：insert
    修改：update
    删除：delete
*/
```

#### 1.4.1 插入

##### 1-1 经典插入

```mysql
*
语法：
insert into 表名(列名,...) values(值1,...);

*/
SELECT * FROM beauty;
#1.插入的值的类型要与列的类型一致或兼容
INSERT INTO beauty(id,NAME,sex,borndate,phone,photo,boyfriend_id)
VALUES(13,'唐艺昕','女','1990-4-23','1898888888',NULL,2);

#2.不可以为null的列必须插入值。可以为null的列如何插入值？
#方式一：
INSERT INTO beauty(id,NAME,sex,borndate,phone,photo,boyfriend_id)
VALUES(13,'唐艺昕','女','1990-4-23','1898888888',NULL,2);

#方式二：
INSERT INTO beauty(id,NAME,sex,phone)
VALUES(15,'娜扎','女','1388888888');

#3.列的顺序是否可以调换
INSERT INTO beauty(NAME,sex,id,phone)
VALUES('蒋欣','女',16,'110');


#4.列数和值的个数必须一致
INSERT INTO beauty(NAME,sex,id,phone)
VALUES('关晓彤','女',17,'110');

#5.可以省略列名，默认所有列，而且列的顺序和表中列的顺序一致
INSERT INTO beauty
VALUES(18,'张飞','男',NULL,'119',NULL,NULL);

```

##### 1-2 插入方式 2

```mysql
/*

语法：
insert into 表名
set 列名=值,列名=值,...
*/

INSERT INTO beauty
SET id=19,NAME='刘涛',phone='999';

```

##### 1-3 两种方式比较

```mysql
#1、方式一支持插入多行,方式二不支持

INSERT INTO beauty
VALUES(23,'唐艺昕1','女','1990-4-23','1898888888',NULL,2)
,(24,'唐艺昕2','女','1990-4-23','1898888888',NULL,2)
,(25,'唐艺昕3','女','1990-4-23','1898888888',NULL,2);

#2、方式一支持子查询，方式二不支持
INSERT INTO beauty(id,NAME,phone)
SELECT 26,'宋茜','11809866';

INSERT INTO beauty(id,NAME,phone)
SELECT id,boyname,'1234567'
FROM boys WHERE id<3;
```

#### 1.4.2 修改

```mysql
/*

1.修改单表的记录★

语法：
    update 表名
    set 列=新值,列=新值,...
    where 筛选条件;

2.修改多表的记录【补充】

    语法：
    sql92语法：
    update 表1 别名,表2 别名
    set 列=值,...
    where 连接条件
    and 筛选条件;

sql99语法：
    update 表1 别名
    inner|left|right join 表2 别名
    on 连接条件
    set 列=值,...
    where 筛选条件;

*/
```

##### 2-1 修改单表记录

```mysql
#案例1：修改beauty表中姓唐的女神的电话为13899888899

UPDATE beauty SET phone = '13899888899'
WHERE NAME LIKE '唐%';

#案例2：修改boys表中id好为2的名称为张飞，魅力值 10
UPDATE boys SET boyname='张飞',usercp=10
WHERE id=2;
```

##### 2-2 修改多表记录

```mysql
#案例 1：修改张无忌的女朋友的手机号为114
UPDATE boys bo
INNER JOIN beauty b ON bo.`id`=b.`boyfriend_id`
SET b.`phone`='119',bo.`userCP`=1000
WHERE bo.`boyName`='张无忌';

#案例2：修改没有男朋友的女神的男朋友编号都为2号
UPDATE boys bo
RIGHT JOIN beauty b ON bo.`id`=b.`boyfriend_id`
SET b.`boyfriend_id`=2
WHERE bo.`id` IS NULL;

SELECT * FROM boys;
```

#### 1.4.3 删除语句

```mysql
/*

方式一：delete
语法：

1、单表的删除【★】
    delete from 表名 where 筛选条件

2、多表的删除【补充】
sql92语法：
    delete 表1的别名,表2的别名
    from 表1 别名,表2 别名
    where 连接条件
    and 筛选条件;

sql99语法：
    delete 表1的别名,表2的别名
    from 表1 别名
    inner|left|right join 表2 别名 on 连接条件
    where 筛选条件;

方式二：truncate
语法：truncate table 表名;

*/

```

##### 3-1 delete

###### 1-1 单表删除

```mysql
#案例：删除手机号以9结尾的女神信息
DELETE FROM beauty WHERE phone LIKE '%9';
SELECT * FROM beauty;

```

###### 1-2 多表删除

```mysql
#案例：删除张无忌的女朋友的信息
DELETE b
FROM beauty b
INNER JOIN boys bo ON b.`boyfriend_id` = bo.`id`
WHERE bo.`boyName`='张无忌';

#案例：删除黄晓明的信息以及他女朋友的信息
DELETE b,bo
FROM beauty b
INNER JOIN boys bo ON b.`boyfriend_id`=bo.`id`
WHERE bo.`boyName`='黄晓明';
```

##### 3-2 truncate 语句

```mysql
#案例：将魅力值>100的男神信息删除
TRUNCATE TABLE boys
```

##### 3-3 delete pk truncate

```mysql
/*

1.delete 可以加where 条件，truncate不能加

2.truncate删除，效率高一丢丢
3.假如要删除的表中有自增长列，
如果用delete删除后，再插入数据，自增长列的值从断点开始，而truncate删除后，再插入数据，自增长列的值从1开始。
4.truncate删除没有返回值，delete删除有返回值

5.truncate删除不能回滚，delete删除可以回滚.
*/

SELECT * FROM boys;

DELETE FROM boys;
TRUNCATE TABLE boys;
INSERT INTO boys (boyname,usercp)
VALUES('张飞',100),('刘备',100),('关云长',100);
```

#### 1.4.4 案例讲解

```mysql
#1.	运行以下脚本创建表my_employees

USE myemployees;
CREATE TABLE my_employees(
    Id INT(10),
    First_name VARCHAR(10),
    Last_name VARCHAR(10),
    Userid VARCHAR(10),
    Salary DOUBLE(10,2)
);
CREATE TABLE users(
    id INT,
    userid VARCHAR(10),
    department_id INT

);
#2.	显示表my_employees的结构
    DESC my_employees;

#3.	向my_employees表中插入下列数据
    ID	FIRST_NAME	LAST_NAME	USERID	SALARY
    1	patel		Ralph		Rpatel	895
    2	Dancs		Betty		Bdancs	860
    3	Biri		Ben		Bbiri	1100
    4	Newman		Chad		Cnewman	750
    5	Ropeburn	Audrey		Aropebur	1550

#方式一：
    INSERT INTO my_employees
    VALUES(1,'patel','Ralph','Rpatel',895),
    (2,'Dancs','Betty','Bdancs',860),
    (3,'Biri','Ben','Bbiri',1100),
    (4,'Newman','Chad','Cnewman',750),
    (5,'Ropeburn','Audrey','Aropebur',1550);

    DELETE FROM my_employees;

#方式二：
    INSERT INTO my_employees
    SELECT 1,'patel','Ralph','Rpatel',895 UNION
    SELECT 2,'Dancs','Betty','Bdancs',860 UNION
    SELECT 3,'Biri','Ben','Bbiri',1100 UNION
    SELECT 4,'Newman','Chad','Cnewman',750 UNION
    SELECT 5,'Ropeburn','Audrey','Aropebur',1550;

#4.	 向users表中插入数据
    1	Rpatel	10
    2	Bdancs	10
    3	Bbiri	20
    4	Cnewman	30
    5	Aropebur	40

    INSERT INTO users
    VALUES(1,'Rpatel',10),
    (2,'Bdancs',10),
    (3,'Bbiri',20);

#5.将3号员工的last_name修改为“drelxer”
    UPDATE my_employees SET last_name='drelxer' WHERE id = 3;

#6.将所有工资少于900的员工的工资修改为1000
    UPDATE my_employees SET salary=1000 WHERE salary<900;

#7.将userid 为Bbiri的user表和my_employees表的记录全部删除
    DELETE u,e
    FROM users u
    JOIN my_employees e ON u.`userid`=e.`Userid`
    WHERE u.`userid`='Bbiri';

#8.删除所有数据
    DELETE FROM my_employees;
    DELETE FROM users;

#9.检查所作的修正
    SELECT * FROM my_employees;
    SELECT * FROM users;

#10.清空表my_employees
    TRUNCATE TABLE my_employees;

```

### 1.5 TCL 事务控制语言

#### 1.5.1 事务的属性

```MySQL
1. 原子性
## 事务是一个不可分割的工作单位，事务中的操作要么都发生，要么都不发生
2. 一致性
## 事务必须使数据库从一个形状状态变换到另外一个一致性状态
3. 隔离性
## 一个事务不能被其他事务干扰，事务之间是隔离的，互不干扰
4. 持久性
## 事务一旦被提交，它对数据库中数据的改变就是永久性的
```

#### 1.5.2 事务的创建

```mysql
## 隐式事务：事务没有明显的开启和结束标记，比如 insert，update，delete 语句；
## 显示事务：具有明显的开启和结束标志。先设置自动提交功能为禁用，SET autocommit = 0;
```

```mysql
## 步骤一：开启事务
    1，Set autocommit = 0;
    2，Start transaction;(可选的，可以不写)；

## 步骤二：编写事务中的 SQL 语句
    3，语句 1;（select，insert，update，delete）
    4，语句 2；

## 步骤三：结束事务（提交事务或回滚事务）commit or rollback
```

#### 1.5.3 演示事务的使用步骤

```mysql
#开启事务
    SET autocommit=0;
    START TRANSACTION;

#编写一组事务的语句
    UPDATE account SET balance = 1000 WHERE username='张无忌';
    UPDATE account SET balance = 1000 WHERE username='赵敏';

#结束事务
    ROLLBACK;
    #commit;

```

#### 1.5.4 隔离机制

```mysql
## 对于同时运行的多个事务，当这些事务访问数据库中的相同数据时，如果没有采取必要的隔离机制，就会导致各种并发问题；

## 脏读：对于两个事务 T1，T2，T1 读取了已经被 T2 更新但还没被提交的字段之后，若 T2 回滚，T1 读取的内容就是临时无效的；

## 不可重复读：对于两个事务 T1，T2，T1 读取了一个字段，然后 T2 更新了该字段之后，T1 再次读取该字段，值就不一样了；

## 幻读：对于两个事务 T1，T2，T1 从一个表中读取了一个字段，然后 T2 在该表中插入了一些新的行之后，如果 T1 再次读取同一个表，就会多出几行；
```

#### 1.5.5 四种隔离级别

```mysql
## MySQL 支持 4 种事务隔离级别。MySQL 默认的事务隔离级别为：REPEATABLE READ
```

##### 1.5.6 注意

```mysql
## 1，5.7.2 之前 使用 show variables like 'tx_isoation' 或者 select @@tx_isolation;
## 2 ， 5.7.2 之 后 使 用 show variables like 'transaction_isoation' 或 者 select @@transaction_isoation;

Savepoint:节点名，设置保存点

```

![image-20230924175359617](Python3%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.assets/image-20230924175359617.png)

```mysql
SET autocommit=0;
START TRANSACTION;
DELETE FROM account WHERE id=25;
SAVEPOINT a;#设置保存点
DELETE FROM account WHERE id=28;
ROLLBACK TO a;#回滚到保存点


SELECT * FROM account;
```

#### 1.5.7 演示事务对于 delete 和 truncate 的处理的区别

```mysql
SET autocommit=0;
START TRANSACTION;

DELETE FROM account;
ROLLBACK;

```

#### 1.5.8 视图

```mysql
/*
含义：虚拟表，和普通表一样使用
mysql5.1版本出现的新特性，是通过表动态生成的数据

比如：舞蹈班和普通班级的对比
    创建语法的关键字	是否实际占用物理空间	使用

视图	create view		 只是保存了sql逻辑	   增删改查，只是一般不能增删改

表	 create table	  保存了数据		     增删改查
*/
```

##### 8-1 视图创建

```mysql
/*
语法：
create view 视图名
as
查询语句;

*/
USE myemployees;

#1.查询姓名中包含a字符的员工名、部门名和工种信息
#①创建
CREATE VIEW myv1
AS

SELECT last_name,department_name,job_title
FROM employees e
JOIN departments d ON e.department_id  = d.department_id
JOIN jobs j ON j.job_id  = e.job_id;


#②使用
SELECT * FROM myv1 WHERE last_name LIKE '%a%';

#2.查询各部门的平均工资级别

    #①创建视图查看每个部门的平均工资
        CREATE VIEW myv2
        AS
        SELECT AVG(salary) ag,department_id
        FROM employees
        GROUP BY department_id;

    #②使用
        SELECT myv2.`ag`,g.grade_level
        FROM myv2
        JOIN job_grades g
        ON myv2.`ag` BETWEEN g.`lowest_sal` AND g.`highest_sal`;



#3.查询平均工资最低的部门信息
SELECT * FROM myv2 ORDER BY ag LIMIT 1;

#4.查询平均工资最低的部门名和工资
CREATE VIEW myv3
AS
SELECT * FROM myv2 ORDER BY ag LIMIT 1;

SELECT d.*,m.ag
FROM myv3 m
JOIN departments d
ON m.`department_id`=d.`department_id`;

```

##### 8-2 视图的修改

###### 2-1 方式 1：

```mysql
#方式一：
/*
create or replace view  视图名
as
查询语句;
*/
SELECT * FROM myv3

CREATE OR REPLACE VIEW myv3
AS
SELECT AVG(salary),job_id
FROM employees
GROUP BY job_id;
```

###### 2-2 方式 2：

```mysql
/*
语法：
alter view 视图名
as
查询语句;
*/
ALTER VIEW myv3
AS
SELECT * FROM employees;
```

##### 8-3 视图的删除

```mysql
/*
语法：drop view 视图名,视图名,...;
*/

DROP VIEW emp_v1,emp_v2,myv3;
```

##### 8-4 查看视图

```mysql
DESC myv3;

SHOW CREATE VIEW myv3;
```

##### 8-5 视图的更新

```mysql
CREATE OR REPLACE VIEW myv1
AS
SELECT last_name,email,salary*12*(1+IFNULL(commission_pct,0)) "annual salary"
FROM employees;

CREATE OR REPLACE VIEW myv1
AS
SELECT last_name,email
FROM employees;

SELECT * FROM myv1;
SELECT * FROM employees;
```

###### 5-1 插入

```mysql
INSERT INTO myv1 VALUES('张飞','zf@qq.com');
```

###### 5-2 修改

```mysql
UPDATE myv1 SET last_name = '张无忌' WHERE last_name='张飞';
```

###### 5-3 删除

```mysql
DELETE FROM myv1 WHERE last_name = '张无忌';
```

###### 5-4 注意

```mysql
#具备以下特点的视图不允许更新
#①包含以下关键字的sql语句：分组函数、distinct、group  by、having、union或者union all

CREATE OR REPLACE VIEW myv1
AS
SELECT MAX(salary) m,department_id
FROM employees
GROUP BY department_id;

SELECT * FROM myv1;

#更新
UPDATE myv1 SET m=9000 WHERE department_id=10;

#②常量视图
CREATE OR REPLACE VIEW myv2
AS
SELECT 'john' NAME;

SELECT * FROM myv2;

#更新
UPDATE myv2 SET NAME='lucy';


#③Select中包含子查询
CREATE OR REPLACE VIEW myv3
AS

SELECT department_id,(SELECT MAX(salary) FROM employees) 最高工资
FROM departments;

#更新
SELECT * FROM myv3;
UPDATE myv3 SET 最高工资=100000;

#④join
CREATE OR REPLACE VIEW myv4
AS

SELECT last_name,department_name
FROM employees e
JOIN departments d
ON e.department_id  = d.department_id;

#更新

SELECT * FROM myv4;
UPDATE myv4 SET last_name  = '张飞' WHERE last_name='Whalen';
INSERT INTO myv4 VALUES('陈真','xxxx');

#⑤from一个不能更新的视图
CREATE OR REPLACE VIEW myv5
AS

SELECT * FROM myv3;

#更新
SELECT * FROM myv5;

UPDATE myv5 SET 最高工资=10000 WHERE department_id=60;

#⑥where子句的子查询引用了from子句中的表
CREATE OR REPLACE VIEW myv6
AS

SELECT last_name,email,salary
FROM employees
WHERE employee_id IN(
    SELECT  manager_id
    FROM employees
    WHERE manager_id IS NOT NULL
);

#更新
SELECT * FROM myv6;
UPDATE myv6 SET salary=10000 WHERE last_name = 'k_ing';
```

#### 1.5.9 视图案例讲解

```mysql
#一、创建视图emp_v1,要求查询电话号码以‘011’开头的员工姓名和工资、邮箱
CREATE OR REPLACE VIEW emp_v1
AS
SELECT last_name,salary,email
FROM employees
WHERE phone_number LIKE '011%';

#二、创建视图emp_v2，要求查询部门的最高工资高于12000的部门信息
CREATE OR REPLACE VIEW emp_v2
AS
SELECT MAX(salary) mx_dep,department_id
FROM employees
GROUP BY department_id
HAVING MAX(salary)>12000;

SELECT d.*,m.mx_dep
FROM departments d
JOIN emp_v2 m
ON m.department_id = d.`department_id`;
```

#### 1.5.10 变量

##### 10-1 系统变量

```mysql
## 系统变量：变量由系统提供，不是用户定义，属于服务器层面

## 1，查看所有的系统变量
    SHOW VARIABLES;

## 2，查看满足条件的部分系统变量；
    SHOW VARIABLES LIKE '%char%';

## 3，查看指定的某个系统的变量值；
    SELECT @@character_set_client;
    @@global.变量名 @@session.变量名 @@变量名

## 4，为系统变量名赋值
    1，set 变量名 = 值（global.变量名||session.变量名）
    2，Set @@global.变量名 = 值 (session.变量名)

## 如果是全局级别加 global，如果是会话级别加 session 关键字
```

###### 1-1 全局变量

```mysql
## 全局变量
SHOW GLOBAL VARIABLES;
    (1) 查看部分全局变量：
        SHOW GLOBAL VARIABLES LIKE '%char%'；

    (2) 查看指定的全局变量的值：
        SELECT @@global.autocommit;
    (3) 为某个指定的全局变量赋值
        SET @@global.autocommit=0;

## 作用域：服务器每次启动将为所有的全局变量赋初始值，针对于所有的会话（连接有效），但不能跨重启
```

###### 1-2 会话变量

```mysql
SHOW SESSION VARIABLES;
## 作用域：仅仅针对于当前的会话（连接有效）

(1) 查看部分会话变量：
    SHOW SESSION VARIABLES LIKE '%char%'；

(2) 查看指定的全局变量的值：
    SELECT @@SESSION.autocommit;

(3) 为某个指定的全局变量赋值
    SET @@SESSION.变量名=值;
```

##### 10-2 自定义变量

```mysql
## 自定义变量: 用户自定义的变量，不是系统提供的
```

###### 2-1 用户变量

```mysql
## 作用域：仅仅针对于当前的会话（连接有效）可以应用在任何地方

1 声明并初始化
    ## （1）SET @用户变量名:=值；(为了不跟等号起冲突);
    ## （2）SET @用户变量名=值；
    ## （3）SELECT @用户变量名:=值；

2 更新用户变量的值（跟声明初始化一样）
    ## (1) SET @用户变量名:=值；(为了不跟等号起冲突);
    ## (2) SET @用户变量名=值；
    ## (3) SELECT @用户变量名:=值；
    ## (4) SELECT 字段 INTO @变量名 FROM 表（查询出来的值必须是一个值才能赋给这个变量）
```

```mysql
3 查看用户变量的值
    ## （1）SELECT @用户变量名
```

###### 2-2 局部变量

```mysql
## 作用域：仅仅在定义它的 begin end 中有效；
1) 声明：DECLARE 变量名 类型 || DECLARE 变量名 类型 DEFAULT 值；

2) 赋值：
    ## （1）SET 用户变量名:=值；(为了不跟等号起冲突);
    ## （2）SET 用户变量名=值；
    ## （3）SELECT 用户变量名:=值；
    ## （4）SELECT 字段 INTO 变量名 FROM 表

3) 使用：SELECT 局部变量名；
```

###### 2-3 案例

```mysql
#案例：声明两个变量，求和并打印

#用户变量
SET @m=1;
SET @n=1;
SET @sum=@m+@n;
SELECT @sum;

#局部变量
DECLARE m INT DEFAULT 1;
DECLARE n INT DEFAULT 1;
DECLARE SUM INT;
SET SUM=m+n;
SELECT SUM;


#用户变量和局部变量的对比

           作用域			    定义位置		     语法
用户变量	当前会话		    会话的任何地方		   加@符号，不用指定类型
局部变量	定义它的BEGIN END中 	BEGIN END的第一句话	  一般不用加@,需要指定类型

```

#### 1.5.11 存储过程函数

```mysql
/*
含义：一组预先编译好的 SQL 语句的集合，理解成批处理语句
    （1）提高代码的重用性；
    （2）简化操作；
    （3）减少了编译次数和数据库服务器的连接次数，提高了效率；

A.创建语法：CREATE PROCEDURE 存储过程名字(参数列表) BEGIN 存储过程体 END;
    (1)参数列表包含三部分：参数模式 参数名 参数类型： In stuname varchar(20);
    (2)参数模式：（三种模式）
        a.In：该参数可以作为输入，需要调用方传入值；
        b.Out：该参数可以作为输出，也就是说该参数可以作为返回值；
        c.Inout：该参数既可以作为输入，又可以作为输出；
    (3)如果存储过程仅仅只有一句话则begin end可以省略；
    (4)存储过程中的每条SQL语句结尾要求必须加分号，存储过程结尾可以使用delimiter 结束标记
    (5)调用语法：call 存储过程名(实参列表);

*/
```

##### 11-1 创建语法

```mysql
CREATE PROCEDURE 存储过程名(参数列表)
BEGIN

    存储过程体（一组合法的SQL语句）
END

#注意：
/*
1、参数列表包含三部分
参数模式  参数名  参数类型
举例：
in stuname varchar(20)

参数模式：
in：该参数可以作为输入，也就是该参数需要调用方传入值
out：该参数可以作为输出，也就是该参数可以作为返回值
inout：该参数既可以作为输入又可以作为输出，也就是该参数既需要传入值，又可以返回值

2、如果存储过程体仅仅只有一句话，begin end可以省略
存储过程体中的每条sql语句的结尾要求必须加分号。
存储过程的结尾可以使用 delimiter 重新设置
语法：
delimiter 结束标记
案例：
delimiter $
*/
```

##### 11-2 调用语法

```mysql
CALL 存储过程名(实参列表);
```

###### 2-1 空参列表

```mysql
#案例：插入到admin表中五条记录

SELECT * FROM admin;

DELIMITER $
CREATE PROCEDURE myp1()
BEGIN
    INSERT INTO admin(username,`password`)
    VALUES('john1','0000'),('lily','0000'),('rose','0000'),('jack','0000'),('tom','0000');
END $

#调用
CALL myp1()$
```

###### 2-2 in 模式

```mysql
#案例1：创建存储过程实现 根据女神名，查询对应的男神信息

CREATE PROCEDURE myp2(IN beautyName VARCHAR(20))
BEGIN
    SELECT bo.*
    FROM boys bo
    RIGHT JOIN beauty b ON bo.id = b.boyfriend_id
    WHERE b.name=beautyName;


END $

#调用
CALL myp2('柳岩')$

#案例2 ：创建存储过程实现，用户是否登录成功

CREATE PROCEDURE myp4(IN username VARCHAR(20),IN PASSWORD VARCHAR(20))
BEGIN
    DECLARE result INT DEFAULT 0;#声明并初始化

    SELECT COUNT(*) INTO result#赋值
    FROM admin
    WHERE admin.username = username
    AND admin.password = PASSWORD;

    SELECT IF(result>0,'成功','失败');#使用
END $

#调用
CALL myp3('张飞','8888')$

```

###### 2-3 out 模式

```mysql
#案例1：根据输入的女神名，返回对应的男神名
CREATE PROCEDURE myp6(IN beautyName VARCHAR(20),OUT boyName VARCHAR(20))
BEGIN
    SELECT bo.boyname INTO boyname
    FROM boys bo
    RIGHT JOIN
    beauty b ON b.boyfriend_id = bo.id
    WHERE b.name=beautyName ;

END $


#案例2：根据输入的女神名，返回对应的男神名和魅力值
CREATE PROCEDURE myp7(IN beautyName VARCHAR(20),OUT boyName VARCHAR(20),OUT usercp INT)
BEGIN
    SELECT boys.boyname ,boys.usercp INTO boyname,usercp
    FROM boys
    RIGHT JOIN
    beauty b ON b.boyfriend_id = boys.id
    WHERE b.name=beautyName ;
END $

#调用
CALL myp7('小昭',@name,@cp)$
SELECT @name,@cp$
```

###### 2-4 in-out 模式

```mysql
#案例1：传入a和b两个值，最终a和b都翻倍并返回

CREATE PROCEDURE myp8(INOUT a INT ,INOUT b INT)
BEGIN
    SET a=a*2;
    SET b=b*2;
END $

#调用
SET @m=10$
SET @n=20$
CALL myp8(@m,@n)$
SELECT @m,@n$

```

##### 11-3 删除存储过程

```mysql
#语法：drop procedure 存储过程名
DROP PROCEDURE p1;
DROP PROCEDURE p2,p3;#×
```

##### 11-4 查看存储过程

```mysql
DESC myp2;
SHOW CREATE PROCEDURE  myp2;
```

##### 11-5 存储过程案例讲解

```mysql
#一、创建存储过程实现传入用户名和密码，插入到admin表中

CREATE PROCEDURE test_pro1(IN username VARCHAR(20),IN loginPwd VARCHAR(20))
BEGIN
    INSERT INTO admin(admin.username,PASSWORD)
    VALUES(username,loginpwd);
END $

#二、创建存储过程实现传入女神编号，返回女神名称和女神电话

CREATE PROCEDURE test_pro2(IN id INT,OUT NAME VARCHAR(20),OUT phone VARCHAR(20))

BEGIN
    SELECT b.name ,b.phone INTO NAME,phone
    FROM beauty b
    WHERE b.id = id;

END $
#三、创建存储存储过程或函数实现传入两个女神生日，返回大小

CREATE PROCEDURE test_pro3(IN birth1 DATETIME,IN birth2 DATETIME,OUT result INT)
BEGIN
    SELECT DATEDIFF(birth1,birth2) INTO result;
END $
#四、创建存储过程或函数实现传入一个日期，格式化成xx年xx月xx日并返回
CREATE PROCEDURE test_pro4(IN mydate DATETIME,OUT strDate VARCHAR(50))
BEGIN
    SELECT DATE_FORMAT(mydate,'%y年%m月%d日') INTO strDate;
END $

CALL test_pro4(NOW(),@str)$
SELECT @str $

#五、创建存储过程或函数实现传入女神名称，返回：女神 and 男神  格式的字符串
如 传入 ：小昭
返回： 小昭 AND 张无忌
DROP PROCEDURE test_pro5 $
CREATE PROCEDURE test_pro5(IN beautyName VARCHAR(20),OUT str VARCHAR(50))
BEGIN
    SELECT CONCAT(beautyName,' and ',IFNULL(boyName,'null')) INTO str
    FROM boys bo
    RIGHT JOIN beauty b ON b.boyfriend_id = bo.id
    WHERE b.name=beautyName;
    SET str=
END $

CALL test_pro5('柳岩',@str)$
SELECT @str $

#六、创建存储过程或函数，根据传入的条目数和起始索引，查询beauty表的记录
DROP PROCEDURE test_pro6$
CREATE PROCEDURE test_pro6(IN startIndex INT,IN size INT)
BEGIN
    SELECT * FROM beauty LIMIT startIndex,size;
END $

CALL test_pro6(3,5)$
```

#### 1.5.12 函数

##### 12-1 创建语法

```mysql
create function 函数名(函数列表) returns 返回类型 begin 函数体 end

/*
含义：一组预先编译好的SQL语句的集合，理解成批处理语句
1、提高代码的重用性
2、简化操作
3、减少了编译次数并且减少了和数据库服务器的连接次数，提高了效率

区别：
存储过程：可以有0个返回，也可以有多个返回，适合做批量插入、批量更新
函数：有且仅有1 个返回，适合做处理数据后返回一个结果

*/
```

##### 12-2 注意

```mysql
1.参数列表包含两个部分，参数名和参数类型；
2.函数体肯定会有return语句，如果没有会报错；如果return语句没有放在函数体的最后也不报错但不建议
3.函数体中仅有一句话则可以省略begin end；
4.使用delimiter语句设置结束标记；
```

##### 12-3 调用语法

```mysql
SELECT 函数名(参数列表)
```

###### 3-1 无参有返回

```mysql
#1.无参有返回
#案例：返回公司的员工个数
CREATE FUNCTION myf1() RETURNS INT
BEGIN
    DECLARE c INT DEFAULT 0;#定义局部变量
    SELECT COUNT(*) INTO c#赋值
    FROM employees;
    RETURN c;
END $

SELECT myf1()$
```

###### 3-2 有参有返回

```MySQL
#案例1：根据员工名，返回它的工资
CREATE FUNCTION myf2(empName VARCHAR(20)) RETURNS DOUBLE
BEGIN
    SET @sal=0;#定义用户变量
    SELECT salary INTO @sal   #赋值
    FROM employees
    WHERE last_name = empName;

    RETURN @sal;
END $

SELECT myf2('k_ing') $

#案例2：根据部门名，返回该部门的平均工资
CREATE FUNCTION myf3(deptName VARCHAR(20)) RETURNS DOUBLE
BEGIN
    DECLARE sal DOUBLE ;
    SELECT AVG(salary) INTO sal
    FROM employees e
    JOIN departments d ON e.department_id = d.department_id
    WHERE d.department_name=deptName;
    RETURN sal;
END $

SELECT myf3('IT')$
```

##### 12-4 查看函数

```mysql
SHOW CREATE FUNCTION myf3;
```

##### 12 -5 删除函数

```mysql
DROP FUNCTION myf3;
```

##### 12-6 案例

```mysql
#一、创建函数，实现传入两个float，返回二者之和
CREATE FUNCTION test_fun1(num1 FLOAT,num2 FLOAT) RETURNS FLOAT
BEGIN
    DECLARE SUM FLOAT DEFAULT 0;
    SET SUM=num1+num2;
    RETURN SUM;
END $

SELECT test_fun1(1,2)$

```

#### 1.5.13 流程控制机构

##### 13-1 分支结构

###### 1-1 if 函数

```mysql
## 语法：
    ## IF(表达式1，表达式2，表达式3)；
    ## 如果表达式1成立，则返回表达式2的值，不成立则返回表达式3的值；
```

###### 1-2 case 结构

```mysql
①　一般用于实现等值判断；
②　一般用于实现区间判断

语法1：
    CASE 变量|表达式|字段
    WHEN 要判断的值1 THEN 返回的值1
    WHEN 要判断的值2 THEN 返回的值2
    WHEN 要判断的值3 THEN 返回的值3
    ...
    ELSE 要返回的值n
    END CASE;
语法2：
    CASE
    WHEN 要判断的条件1 THEN 返回的语句1或值；
    WHEN 要判断的条件2 THEN 返回的值2或语句；
    WHEN 要判断的条件3 THEN 返回的值3或语句；
    ...
    ELSE 要返回的条件n
    END CASE;
## 特点：可以作为表达式，嵌套在其他语句中使用；也可以作为独立的语句使用（可以放在任何地方）如果作为独立的语句只用，只能放在begin end中


#案例1：创建函数，实现传入成绩，如果成绩>90,返回A，如果成绩>80,返回B，如果成绩>60,返回C，否则返回D
CREATE FUNCTION test_case(score FLOAT) RETURNS CHAR
BEGIN
    DECLARE ch CHAR DEFAULT 'A';
    CASE
    WHEN score>90 THEN SET ch='A';
    WHEN score>80 THEN SET ch='B';
    WHEN score>60 THEN SET ch='C';
    ELSE SET ch='D';
    END CASE;
    RETURN ch;
END $

SELECT test_case(56)$
```

###### 1-3 if 结构

```mysql
## 语法：
        IF 条件1 THEN 语句1；
        ELSEIF 条件2 THEN 语句2；
        ,,,
        ELSE 条件n;
        END IF;

## 应用在begin end 中；

#案例1：创建函数，实现传入成绩，如果成绩>90,返回A，如果成绩>80,返回B，如果成绩>60,返回C，否则返回D
CREATE FUNCTION test_if(score FLOAT) RETURNS CHAR
BEGIN
    DECLARE ch CHAR DEFAULT 'A';
    IF score>90 THEN SET ch='A';
    ELSEIF score>80 THEN SET ch='B';
    ELSEIF score>60 THEN SET ch='C';
    ELSE SET ch='D';
    END IF;
    RETURN ch;
END $

SELECT test_if(87)$


#案例2：创建存储过程，如果工资<2000,则删除，如果5000>工资>2000,则涨工资1000，否则涨工资500
CREATE PROCEDURE test_if_pro(IN sal DOUBLE)
BEGIN
    IF sal<2000 THEN DELETE FROM employees WHERE employees.salary=sal;
    ELSEIF sal>=2000 AND sal<5000 THEN UPDATE employees SET salary=salary+1000 WHERE employees.`salary`=sal;
    ELSE UPDATE employees SET salary=salary+500 WHERE employees.`salary`=sal;
    END IF;

END $

CALL test_if_pro(2100)$
```

##### 13-2 循环结构

###### 2-1 分类

```mysql
WHILE, LOOP, REPEAT,
1.ITERATE 类似于continue，结束本次循环，继续下次循环；
2.LEAVE 类似于 break，跳出，结束当前所在的循环；
```

###### 2-2 语法

```mysql
#1.while
/*
语法：

【标签:】while 循环条件 do
    循环体;
end while【 标签】;


while(循环条件){
    循环体;
}
*/

#2.loop
/*
语法：
【标签:】loop
    循环体;
end loop 【标签】;

可以用来模拟简单的死循环
*/

#3.repeat
/*
语法：
【标签：】repeat
    循环体;
until 结束循环的条件
end repeat 【标签】;

*/
```

###### 2-3 案例

```mysql
#1.没有添加循环控制语句
#案例：批量插入，根据次数插入到admin表中多条记录
DROP PROCEDURE pro_while1$
CREATE PROCEDURE pro_while1(IN insertCount INT)
BEGIN
    DECLARE i INT DEFAULT 1;
    WHILE i<=insertCount DO
        INSERT INTO admin(username,`password`) VALUES(CONCAT('Rose',i),'666');
        SET i=i+1;
    END WHILE;

END $

CALL pro_while1(100)$


/*

int i=1;
while(i<=insertcount){

    //插入

    i++;

}

*/


#2.添加leave语句

#案例：批量插入，根据次数插入到admin表中多条记录，如果次数>20则停止
TRUNCATE TABLE admin$
DROP PROCEDURE test_while1$
CREATE PROCEDURE test_while1(IN insertCount INT)
BEGIN
    DECLARE i INT DEFAULT 1;
    a:WHILE i<=insertCount DO
        INSERT INTO admin(username,`password`) VALUES(CONCAT('xiaohua',i),'0000');
        IF i>=20 THEN LEAVE a;
        END IF;
        SET i=i+1;
    END WHILE a;
END $


CALL test_while1(100)$


#3.添加iterate语句

#案例：批量插入，根据次数插入到admin表中多条记录，只插入偶数次
TRUNCATE TABLE admin$
DROP PROCEDURE test_while1$
CREATE PROCEDURE test_while1(IN insertCount INT)
BEGIN
    DECLARE i INT DEFAULT 0;
    a:WHILE i<=insertCount DO
        SET i=i+1;
        IF MOD(i,2)!=0 THEN ITERATE a;
        END IF;

        INSERT INTO admin(username,`password`) VALUES(CONCAT('xiaohua',i),'0000');

    END WHILE a;
END $

CALL test_while1(100)$

/*

int i=0;
while(i<=insertCount){
    i++;
    if(i%2==0){
        continue;
    }
    插入
}
*/

```

##### 13-3 流程控制案例讲解

```mysql
/*一、已知表stringcontent
其中字段：
id 自增长
content varchar(20)

向该表插入指定个数的，随机的字符串
*/
DROP TABLE IF EXISTS stringcontent;
CREATE TABLE stringcontent(
    id INT PRIMARY KEY AUTO_INCREMENT,
    content VARCHAR(20)

);
DELIMITER $
CREATE PROCEDURE test_randstr_insert(IN insertCount INT)
BEGIN
    DECLARE i INT DEFAULT 1;
    DECLARE str VARCHAR(26) DEFAULT 'abcdefghijklmnopqrstuvwxyz';
    DECLARE startIndex INT;#代表初始索引
    DECLARE len INT;#代表截取的字符长度
    WHILE i<=insertcount DO
        SET startIndex=FLOOR(RAND()*26+1);#代表初始索引，随机范围1-26
        SET len=FLOOR(RAND()*(20-startIndex+1)+1);#代表截取长度，随机范围1-（20-startIndex+1）
        INSERT INTO stringcontent(content) VALUES(SUBSTR(str,startIndex,len));
        SET i=i+1;
    END WHILE;

END $

CALL test_randstr_insert(10)$
```

### 1.6 ，python 连接 MySQL

#### 1.6.1 连接数据库

```Python
import pymysql

# 连接MySQL数据库
db = pymysql.connect(host='127.0.0.1', user='root', password='123456', database='test',port=3306)

# 设置字符集  防止乱码
db.set_charset('utf8')

# 创建游标对象
cursor = db.cursor()

# 准备SQL
sql = 'select * from user'
# 执行SQL语句
cursor.execute(sql)

# 获取所有
print(cursor.fetchall())
print(cursor.fetchone())


# 关闭数据库连接
db.close()
```

#### 1.6.2 事件回滚

```Python
import pymysql


# 连接MySQL数据库
db = pymysql.connect(host='127.0.0.1', user='root', password='123456', database='test',port=3306)

# 设置字符集  防止乱码
db.set_charset('utf8')

# 创建游标对象
cursor = db.cursor()

try:
    # 准备插入SQL语句
    sql = 'insert into user values(4,"刘强东", 50, "男")'
    # 执行SQL语句
    cursor.execute(sql)
    # 提交事务 保存到数据库中
    db.commit()
except Exception as e:
    print(e)
    # 回滚
    db.rollback()
# 对于插入获取受影响的行数
print(cursor.rowcount)

# 关闭数据库连接
db.close()
```

## 2，Redis

### 举例（普通连接）：

```python
import redis

# decode_responses=True  自动解码
r = redis.Redis(host='127.0.0.1',port=6379,password='123456',db=0,decode_responses=True) #默认数据库为0

r = redis.StrictRedis(host='10.10.2.14',port=6379,password='123456',decode_responses=True)
```

### 连接池：connection pool

管理对一个 redis server 的所有连接，避免每次建立，释放连接的开销。默认，每个 redis 实例都会维护一个自己的连接池，可以直接建立一个连接池，作为参数传给 redis，这样可以实现多个 redis 实例共享一个连接池。

举例（连接池）：

```python
pool = redis.ConnectionPool(host='127.0.0.1',port=6379,db=0,password='123456',decode_responses=True)

r = redis.Redis(connection_pool=pool)
```
